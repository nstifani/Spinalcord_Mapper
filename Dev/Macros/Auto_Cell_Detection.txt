// Defines Global Variables
var PluginName="Spinalcord Mapper";
var MacroName="Auto Cell Detection";
var FileExt="TIF";
var MinNbFile=1;
var FolderSuffix="Auto-Cell-Detection";
var SubDirArray=newArray("ROIs","Results","Parameters","Measurements");
CellSeparator= "\t";
LineSeparator="\n";
//var CounterArray=newArray(0); // This is an array containing the Counter Nb



/////////////// Header, Set Preferences, Options and Housekeeping
// Select All measurements, Invert Y, and use 9 decimals
run("Set Measurements...", "area mean standard modal min centroid center perimeter bounding fit shape feret's integrated median skewness kurtosis area_fraction stack display invert redirect=None decimal=9");
run("Line Width...", "line=1"); // Set Line width as 1
run("Input/Output...", "jpeg=100 gif=-1 file=.txt use copy_row save_column"); // Set Output as Txt and save columns and ignore row numbers
run("Point Tool...", "type=Hybrid color=White size=Large label show counter=0");// Set the Point tool as yellow Medium Circle
run("Colors...", "foreground=white background=black selection=White"); // Set foreground and background colors Selection is yellow
run("Appearance...", "  menu=0 16-bit=Automatic"); // Change appareance of 16bit image as automatic
run("Misc...", "divide=Infinity"); // Make sure Miscellaneous Options are set correctly
run("Overlay Options...", "stroke=White width=2 point=Hybrid size=Large fill=none apply show");
run("Labels...", "color=White font=10 show bold");
call("ij.Prefs.set", "tw.font.size",2);


IJPosX=screenWidth*0.1; // The position of ImageJ in X // Set IJ Size and position
IJPosY=screenHeight*0; // The position of ImageJ in Y at the top of the screen
IJSizeX=570; // The width of ImageJ toolbar in pixel
IJSizeY=100; // The Height of ImageJ toolbar in pixel
Spacer=25; // A spacer
DummyVariable=eval("script","IJ.getInstance().setLocation("+IJPosX+","+IJPosY+");"); // Adjust the position of the ImageJ toolbar

ToolbarSizeX=300;// Set Toolbar Size and position
ToolbarSizeY=200; // Size of the toolbar
ToolbarPosX=IJPosX+IJSizeX+Spacer; // Position of the Toolbar is to the right of the ImageJ toolbar
ToolbarPosY=IJPosY; // Position of to the Toolbar in Y

if(isOpen(PluginName+" Toolbar")){
  selectWindow(PluginName+" Toolbar");
  setLocation(ToolbarPosX,ToolbarPosY);
}

ThresholdSizeX=290;// Set Threshold Window Size and Position
ThresholdSizeY=260;
ThresholdPosX=ToolbarPosX; // The Position in X of the threshold window
ThresholdPosY=ToolbarPosY+ToolbarSizeY+Spacer; // Threshold toolbar is just below the plugin toolbar
call("ij.Prefs.set", "threshold.loc", ThresholdPosX+" , "+ThresholdPosY);

ROIManagerSizeX=250;// Set ROI Manager Size and Position
ROIManagerSizeY=300;
ROIManagerPosX=ToolbarPosX; // The Position in X of the ROI manager window which is to the right of the Treshold widnow
ROIManagerPosY=ThresholdPosY+ThresholdSizeY+Spacer;
call("ij.Prefs.set", "manager.loc", ROIManagerPosX+" , "+ROIManagerPosY);

ResultsSizeX=(screenWidth-(ToolbarPosX+ToolbarSizeX+Spacer)); // Set Results Size and Position to the right of the toolbar until the bottom of Threhsold window
ResultsSizeY=ROIManagerPosY-Spacer;
ResultsPosX=ToolbarPosX+ToolbarSizeX+Spacer;
ResultsPosY=ToolbarPosY;
call("ij.Prefs.set", "results.loc", ResultsPosX+" , "+ResultsPosY);
call("ij.Prefs.set", "results.width", ResultsSizeX);
call("ij.Prefs.set", "results.height", ResultsSizeY);

LogSizeX=(screenWidth-(ToolbarPosX+ToolbarSizeX+Spacer)); // Set Log location
LogSizeY=ROIManagerPosY-Spacer;
LogPosX=ToolbarPosX+ToolbarSizeX+Spacer; // The Position in X of the ROI manager window
LogPosY=ToolbarPosY;
call("ij.Prefs.set", "log.loc", LogPosX+" , "+LogPosY);

DebugSizeX=(screenWidth-(ToolbarPosX+ToolbarSizeX+Spacer)); // Set Debug location
DebugSizeY= ROIManagerPosY-Spacer;
DebugPosX=ToolbarPosX+ToolbarSizeX+Spacer; // The Position in X of the ROI manager window
DebugPosY=ToolbarPosY;
call("ij.Prefs.set", "debug.loc", DebugPosX+" , "+DebugPosY);

PointToolSizeX=250;// Set point Tool location
PointToolSizeY=300;
PointToolPosX= ROIManagerPosX+ROIManagerSizeX+Spacer;
PointToolPosY= ROIManagerPosY;

BCSizeX=150;// Set Brightness and contrast location
BCSizeY=300;
BCPosX=PointToolPosX+PointToolSizeX+Spacer;
BCPosY=ROIManagerPosY;
call("ij.Prefs.set", "b&c.loc", BCPosX+" , "+BCPosY);
//////////////// Header and Housekeeping



//////////////// General Functions
////////// Function to Append a value to an Array and return it
function Append(ArrayI, Value) {
  ArrayJ = newArray(ArrayI.length+1);
  for (ValueI=0; ValueI<ArrayI.length; ValueI++){
  ArrayJ[ValueI] = ArrayI[ValueI];
}
  ArrayJ[ArrayI.length] = Value;
  return ArrayJ;
}
////////// End of Function

////////// Function to display a message
var MessageDialogPass;
function MessageDialog(Message, UtilityWindowsToCloseArray){
  MessageDialogPass=0;
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage(Message);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  CloseUtilityWindows(UtilityWindowsToCloseArray);
  Dialog.show();
  MessageDialogPass=1;
}
////////// End of Function display a message



////////// Function to display an error and propose to Fix it
////////// ErrorResponseArray is an array of options to respond to the error
////////// UtilityWindowsToCloseArray is an array of utility windows to close=newArray("Threshold", "Results", "ROI Manager", "B&C");
var ErrorDialogPass;
function ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray){
  ErrorDialogPass=0;
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage(MessageError);
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage(MessageFix);
  Dialog.setInsets(0, 20, 0);
  Dialog.addRadioButtonGroup("", ErrorResponseArray, ErrorResponseArray.length, 1, ErrorResponseArray[0]);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  CloseUtilityWindows(UtilityWindowsToCloseArray);
  Dialog.show();
  UserResponseErrorDialog=Dialog.getRadioButton();
  return UserResponseErrorDialog;
}
////////// End of Function display an error

////////// Function Select an Input Directory
var SelectInputDirPass; // Switch for the dialog box
var InputDirPath; // Path of the input directory
var ParentDir; // ParentDirectory of the selected input directory
var InputDirName; // Name of the Input Directory
var NbFileWithCorrectExt; // Nb of File with the correct extension in the input directory
var InputItemList; // List of Files and folders in the input directory (all files no matter the extension)
var InputCorrectExtFileList; // List of files with the correct extension
var InputFileList;
var NbFile;

function SelectInputDir(MinNbFile, FileExt){
  // MinNbFile This is the minimum Nb of File to be present in the list to be accepted
  // FileExt This is the File extension as a string example "tif"
  InputDirPath=getDirectory("Select a FOLDER containing at least "+MinNbFile+" "+FileExt+" Files to process."); // Select a Folder
  InputItemList=getFileList(InputDirPath); // List of Item in the selected folder
  InputItemList=Array.sort(InputItemList); // Sort the List of Item
  ParentDir=File.getParent(InputDirPath)+File.separator;
  InputDirName=File.getName(InputDirPath);

  SelectInputDirPass=0; // Switch for the Function
  NbFileWithCorrectExt=0; // Count of Nb of Files
  BaseNameError=0; // Switch to make sure there is only one "." in the filename
  InputCorrectExtFileList=newArray(0);

  // Evaluate the Nb of File with correct extension and add them to InputCorrectExtFileList
  for (ItemI=0; ItemI<InputItemList.length; ItemI++){
    if(endsWith(toLowerCase(InputItemList[ItemI]), "."+toLowerCase(FileExt))){ // Select files with correct extension
      InputCorrectExtFileList=Append(InputCorrectExtFileList, InputItemList[ItemI]);
    }
  }
  NbFileWithCorrectExt=InputCorrectExtFileList.length;
  if(NbFileWithCorrectExt<MinNbFile){ // If the Nb of File with correct extension is not at least equal to the MinNbFile Create Error Message.
    MessageError="Sorry but the Folder:\n\"" +InputDirName+"\"\ndoes not contain at least "+MinNbFile+" "+FileExt+" File.";
    MessageFix=MacroName+" requires a Folder that contains at least "+MinNbFile+" "+FileExt+" File.";
    ErrorResponseArray=newArray("Select Another Folder", "Cancel and Close");
    UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
    UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
    if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
      MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Folder:\n\"" +InputDirName+"\"\ndid not contain at least "+MinNbFile+" "+FileExt+" File.";
      CleanExit(MessageQuit);
    } else {
      // Select Another Folder
      SelectInputDirPass=0;
    }
  } else { // if NbFileWithCorrectExt is above or equal MinNbFile Evaluate Filenames
    InputFileList=newArray(0);
    for (FileI=0; FileI<InputCorrectExtFileList.length; FileI++){
      BasenameFileIArray=split(InputCorrectExtFileList[FileI],"."); // Make an array from the filename
      if(BasenameFileIArray.length!=2){// if there is more than one . in the file name abort
        MessageError="Sorry but the "+FileExt+" File:\n\""+InputCorrectExtFileList[FileI]+"\"\ncontains more than one \".\" in its filename.";
        MessageFix=MacroName+" function does NOT allow filenames with more than one unique \".\" used for the file extension.";
        ErrorResponseArray=newArray("Select Another Folder", "Ignore This File", "Cancel and Close");
        UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
        UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
        if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the File \""+InputCorrectExtFileList[FileI]+"\"\ncontains more than one \".\"\nMake sure filenames have no more than one unique \".\" for the File extension.";
        CleanExit(MessageQuit);
        } else if (UserResponseErrorDialog=="Ignore This File"){
          // Ignore this file
        } else if (UserResponseErrorDialog=="Select Another Folder") {
          FileI=InputCorrectExtFileList.length; // Stop the Loop
          SelectInputDirPass=0;
          ErrorDialogPass=1; // Switch Error Dialog Pass
        }
      }else { // If basename is good add it to the InputFileList
        InputFileList=Append(InputFileList, InputCorrectExtFileList[FileI]);
      }
    }
    // Make sure InpuFileList is > MinNbFile if the ErrorDialog is
    NbFile=InputFileList.length;
    if(NbFile<MinNbFile && ErrorDialogPass!=1){ // If the Nb of File with correct extension is not at least equal to the MinNbFile Create Error Message.
      MessageError="Sorry but the Folder:\n\"" +InputDirName+"\"\ndoes not contain at least "+MinNbFile+" "+FileExt+" File with no more than one \".\" in its filename.";
      MessageFix=MacroName+" requires a Folder that contains at least "+MinNbFile+" "+FileExt+" File with one unique \".\" used for the file extension.";
      ErrorResponseArray=newArray("Select Another Folder", "Cancel and Close");
      UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
      UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
      if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Folder:\n\"" +InputDirName+"\"\ndid not contain at least "+MinNbFile+" "+FileExt+" File no more than one \".\" in its filename.";
        CleanExit(MessageQuit);
      } else {
        SelectInputDirPass=0;
      }
    } else if (ErrorDialogPass==1){
      SelectInputDirPass=0; // InputDir Pass the criteria
    } else {
      SelectInputDirPass=1; // InputDir Pass the criteria
    }
  }
}
////////// End of Function Select InputDir

////////// Function to create Output directory
var OutputDirPath; // The path of the output directory
var OutputDirName; // The name of the output directory
function CreateOutputDir(ParentDir, InputDirName, FolderSuffix){ // Folder suffix is a string appended to the input Directory
  OutputDirPath=ParentDir+InputDirName+"_"+FolderSuffix+File.separator; // Create the outputdirpath
  n=1;
  while(File.exists(OutputDirPath)!=0){ // If the path already exist, increment with _ n until it does not exist
    n++;
    OutputDirPath=ParentDir+InputDirName+"_"+FolderSuffix+"_"+n+File.separator;
  } // End of making sure the outpudirectory is a new folder
  File.makeDirectory(OutputDirPath); // Create the outpudirectory
  OutputDirName=File.getName(OutputDirPath); // Get the Name of the output directory
}
////////// End Function Create Output Directory

////////// Close and CleanUp Function
function CloseAndCleanUp(UtilityWindowsToCloseArray){
  // Close all Images
  ListImages=getList("image.titles");
  for(n=0; n<ListImages.length; n++){
    ImageN=ListImages[n];
    selectWindow(ImageN);    run("Close");
  }

  // Close Utility Windows
  CloseUtilityWindows(UtilityWindowsToCloseArray);

  beep(); // Beep

  //Closing Dialog Information
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage(FileI+" of "+ NbFile+" "+ FileExt+ " Files in the folder:\n"+InputDirName+"\nhave been processed successfully.");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage("Files are saved in the following folder:\n"+OutputDirName+".");
  Dialog.setInsets(0, 0, 0);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
}
////////// End of Close and CleanUp Function

////////// CleanExit Function
function CleanExit(MessageQuit, UtilityWindowsToCloseArray){
 // Close Images
  ListImages=getList("image.titles");
  for(n=0; n<ListImages.length; n++){
    ImageN=ListImages[n];
    selectWindow(ImageN);    run("Close");
  }

  CloseUtilityWindows(UtilityWindowsToCloseArray); // Close Utility windows
  beep(); // Beep

  // Dialog MessageQuit
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage(MessageQuit);
  Dialog.setInsets(0, 0, 0);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  exit();
}
////////// End of CleanExit Function

////////// Close Utility Windows
  // ListUtilityWindows is an array of utility windows to close   ListUtilityWindows=newArray("Threshold", "Results", "ROI Manager", "B&C");
  function CloseUtilityWindows(UtilityWindowsToCloseArray){
  // Typically  UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
    for(WindowI=0; WindowI<UtilityWindowsToCloseArray.length; WindowI++){
    UtilityWindowI=UtilityWindowsToCloseArray[WindowI];
    if(isOpen(UtilityWindowI)){
      if(UtilityWindowI=="Results"){run("Clear Results");}
      if(UtilityWindowI=="ROI Manager"){roiManager("reset");}
      selectWindow(UtilityWindowI); run("Close");
    }
  }
  }
  ////////// End of Close UtilityWindows
////////////////////////////// End of General Functions





////////////////////////////// Specific Functions

////////// Prompt for Global or Individual Procesing Method
var ProcessingMethodPass; // Switch for Processing Method

function ProcessingMethodPrompt (ProcessingMethodArray, ProcessingMethod){
  ProcessingMethodPass=0;
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage("Select the Processing Method:");
  Dialog.addRadioButtonGroup("", ProcessingMethodArray, ProcessingMethodArray.length, 1, ProcessingMethod)
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  ProcessingMethod = Dialog.getRadioButton;
  ProcessingMethodPass=1;
return ProcessingMethod;
}
////////// End of Prompt Processing Method function

///////// Function to create subfolders within the newly create outputdirectory
function CreateOutputSubDir(SubDirArray) { // SubDirArray is an array of the desired subfolders
  for(i=0;i<SubDirArray.length;i++){
    SubDirPath=OutputDirPath+SubDirArray[i]+File.separator; // Because outpudirpath is unique and new the subfolders do not exist yet so no need to check if they are already present
    File.makeDirectory(SubDirPath);
  } // End of for
} // End of CreateOutputSubDir function
// NOTE:It is useful to create a string for the subdirectory paths
// For each element in the subdirarray addMessage
// Output[SubDirArrayElementN]Path=""+OutputDirPath+"[SubDirArrayElementN]"+File.separator;
// Then you can use directly the string to save within a subdirectory

////////////////Function to get Image Info and Save it into arrays
//// Required to see if Global Method can be applied to the select directory
var GetImageInfoPass;
var DimensionArray;
var NbChannelArray;
var NbSliceArray;
var NbFrameArray;
function GetImageInfo (InputFileList){
  GetImageInfoPass=0;
  //setBatchMode(true);
  /////// Open the arrays to store parameters and measurement data
  DimensionArray=newArray(0);
  NbChannelArray=newArray(0);
  NbSliceArray=newArray(0);
  NbFrameArray=newArray(0);

  //Loop around each file
  for (FileI = 0; FileI < InputFileList.length; FileI++){
    InputFileNameI=InputFileList[FileI];
    InputFilePathI = InputDirPath+InputFileNameI;
    open(InputFilePathI);
    //Get the dimension
    getDimensions(WidthI, HeightI, ChannelsI, SlicesI, FramesI);
    close(); // Close the Image
    //Append the Values to the arrays
    DimensionArray=Append(DimensionArray,WidthI);
    DimensionArray=Append(DimensionArray,HeightI);
    NbChannelArray=Append(NbChannelArray,ChannelsI);
    NbSliceArray=Append(NbSliceArray,SlicesI);
    NbFrameArray=Append(NbFrameArray,FramesI);
    showProgress(FileI, InputFileList.length);
  }
  GetImageInfoPass=1;
}///////////// End of Function getImage Info


// This function Prompt to Select the Channels to Process
// Also prompt for Sample detection method
var SelectChannelPass; // Switch for dialog
var NbSelectedCh;
var ListChSelectionStatus;
var AutoSampleDetection;
var ManualSampleDetection;

function SelectChannel(InputFileNameI, MinChNb, MaxChNb){
  SelectChannelPass=0;
  NbSelectedChPass=0;
  ChNamePass=0;
  //setBatchMode("show");
  selectWindow(InputFileNameI);
  setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
  getDimensions(ImageWidth, ImageHeight, ImageChannels, ImageSlices, ImageFrames);
  ListChSelectionStatusString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChSelectionStatusString", "0,0,0,0,0,0,0"); // List of status for 5 channels. 1=selected; 0=ignored.
  ListChNameString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChNameString", "Ch1,Ch2,Ch3,Ch4,Ch5,Ch6,Ch7"); // List of name of 5 channels.
  AutoSampleDetection=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".AutoSampleDetection", 1); // Status of ROI detection methods. First one is Sample detection. Second one is manual selection of ROI. 1=selected; 0=ignored.
  ManualSampleDetection=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ManualSampleDetection", 1); // Status of ROI detection methods. First one is Sample detection. Second one is manual selection of ROI. 1=selected; 0=ignored.
  ListChSelectionStatus=split(ListChSelectionStatusString,",");
  ListChName=split(ListChNameString,",");
  ListChNameCurrentImage=Array.trim(ListChName, ImageChannels);
  ListChSelectionStatusCurrentImage=Array.trim(ListChSelectionStatus, ImageChannels);
  SampleDetectionOptions=newArray("Auto Sample Detection","Manual Sample Detection"); // Status of ROI detection methods. First one is Sample detection. Second one is manual selection of ROI. 1=selected; 0=ignored.

  Dialog.create(PluginName+" Information");
  Dialog.setInsets(5, 0, 0);
  Dialog.addMessage("Select the Channels you would like to process:");
  Dialog.setInsets(5, 20, 0);
  Dialog.addCheckboxGroup(1,ImageChannels, ListChNameCurrentImage, ListChSelectionStatusCurrentImage);
  Dialog.addMessage("Channel Names:");
  for (ChI=0; ChI < ImageChannels; ChI++){
    Dialog.setInsets(5, 40, 0);
    Dialog.addString("Ch "+ChI+1+":", ListChNameCurrentImage[ChI], 10);
  }
  Dialog.setInsets(20, 10, 0);
  Dialog.addMessage("Sample Detection Methods:");
  Dialog.setInsets(5, 10, 0);
  Dialog.addCheckboxGroup(2,1,SampleDetectionOptions,newArray(AutoSampleDetection, ManualSampleDetection));
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+Spacer+15);
  Dialog.show();

  // Get the selection status and channel names
  for (ChI=0; ChI < ImageChannels; ChI++){
    ListChSelectionStatus[ChI]=Dialog.getCheckbox();
    ListChName[ChI]=Dialog.getString();
  }// End of geet the selection status and channel names

  // Get ROI Method
  AutoSampleDetection=Dialog.getCheckbox();
  ManualSampleDetection=Dialog.getCheckbox();
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".AutoSampleDetection",AutoSampleDetection);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ManualSampleDetection",ManualSampleDetection);

  // Get the Nb of Selected Channels
  NbSelectedCh=0;
  for (ChI=0; ChI < ImageChannels; ChI++){
    NbSelectedCh=NbSelectedCh+ListChSelectionStatus[ChI];
  }

  // Chcek the Nb Selected Channels is Valid
  if(isNaN(NbSelectedCh)==1 || NbSelectedCh<MinChNb || NbSelectedCh>MaxChNb || NbSelectedCh<1){ // Make sure the NbSelectedCh is a valid integer or display an error
    if(isNaN(NbSelectedCh)==1){
      MessageError="Sorry but the Number of Selected Channels is not a number.";
    } else if(NbSelectedCh<MinChNb){
      MessageError="Sorry but the Number of Selected Channels is too small.";
    } else if(NbSelectedCh>MaxChNb){
      MessageError="Sorry but the Number of Selected Channels is too big.";
    }else if(NbSelectedCh<1){
      MessageError="Sorry but the Number of Selected Channels is too low.";
    } else {
      MessageError="Sorry but the provided Number of Selected Channels is invalid.";
    }
    // Display an error
    MessageFix=MacroName+" function requires a positive Number of Selected Channels comprised between "+MinChNb+" and "+MaxChNb+".";
    ErrorResponseArray=newArray("Modify the Channel Selection", "Cancel and Close");
    UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
    UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
    if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
    MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Number of Selected Channels was not comprised between "+MinChNb+" and "+MaxChNb+".";
    CleanExit(MessageQuit);
    } else {
      NbSelectedChPass=0;
      SelectChannelPass=0;
      //Reset ChSelectionStatus String
      ListChSelectionStatusString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChSelectionStatusString", "0,0,0,0,0,0,0"); // List of status for 5 channels. 1=selected; 0=ignored.
      ListChSelectionStatus=split(ListChSelectionStatusString,",");
    }
  } else {// If NbCh pass then save it in preferences
    NbSelectedChPass=1;
    ChNamePass=0;
    SelectChannelPass=0;
    //Update and Save Selection status

    for (ChI=0; ChI < ListChSelectionStatus.length ;ChI++){
      if(ChI==0){
        ListChSelectionStatusString=""+ListChSelectionStatus[ChI];
      }else{
        ListChSelectionStatusString=ListChSelectionStatusString+","+ListChSelectionStatus[ChI];
      }
    }// End of recreate the strings from the arrays
    // Save the ID Position, IDs and Names in the preferences
    call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChSelectionStatusString",ListChSelectionStatusString);


    // if Nb SelectedChannels is Valid Check ChannelNames are Valid
    // Make sure ChNames do not contain , nor .
    for (ChI = 0; ChI < ListChName.length; ChI++){
      if(matches(ListChName[ChI],".*[,.].*")==1){
        ChNamePass= -1;
        ChNameError=ListChName[ChI];
      }
    }

    // Make sure ChName of Select Channels are unique
    for (ChIA = 0; ChIA < (ListChName.length)-1; ChIA++){
      if(ListChSelectionStatus[ChIA]==1){
        for (ChIB = ChIA+1; ChIB < ListChName.length; ChIB++){
          if(ListChSelectionStatus[ChIB]==1){
            ChNameA=ListChName[ChIA];
            ChNameB=ListChName[ChIB];
            if(ChNameA==ChNameB){
              ChNameError=ChNameA;
              ChNamePass= -1;
            }
          }
        }
      }
    }// end of evaluate ChNames of Selected Channels

    // Display an error dialog
    if(ChNamePass<0){
      MessageError="Sorry but the Channel Names "+ChNameError+"is not unique or contains a comma \",\" or a dot \".\".";
      MessageFix=MacroName+" function does not allow commas \",\" nor dots \".\" in the Channel Names which must unique.";
      ErrorResponseArray=newArray("Modify the Channel Names", "Cancel and Close");
        UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
    UserResponseErrorDialog=  ErrorDialog(MessageError,MessageFix,ErrorResponseArray, UtilityWindowsToCloseArray);
      if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Channels Names weren't unique and/or contained commas \",\" or dots \".\"";
        CleanExit(MessageQuit);
      } else {
        ChNamePass=0;
      }
    } else {// end of if SelectChannelPass has failed aka is good
      ChNamePass=1;

      //Recreate the Strings from the Arrays
      //Update and Save Selection status
      for (ChI=0; ChI < ListChName.length ;ChI++){
        if(ChI==0){
          ListChNameString=""+ListChName[ChI];
        }else{
          ListChNameString=ListChNameString+","+ListChName[ChI];
        }
      }// End of recreate the strings from the arrays
      // Save Ch Names in the preferences
      call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChNameString",ListChNameString);
    } // end ChName Pass
  }// end of else NbSelectedChannels is Valid
  if(NbSelectedChPass==1 && ChNamePass==1){
    SelectChannelPass=1;
  }
} //////////////////// end of function Select Channels



// Function to TransformSample
var SampleTransformationPromptPass;
//var SampleTransformation;
//var NbIteration;

function SampleTransformationPrompt (SampleTransformation, NbIteration){
  SampleTransformationPromptPass=0;
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage("Select the Transformation and the Number of Iterations to apply to the Sample.");
  SampleTransformationOptions = newArray("None","Open (Erode & Dilate)", "Close (Dilate & Erode)", "Dilate","Erode", "Fill Holes");
  Dialog.setInsets(0, 0, 0);
  Dialog.addRadioButtonGroup("", SampleTransformationOptions, 3, 2, SampleTransformation);
  Dialog.setInsets(0, 0, 0);
  Dialog.addSlider("Number Iterations:",1,20, NbIteration);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  var SampleTransformation = Dialog.getRadioButton;

  if(SampleTransformation==SampleTransformationOptions[0]){
    SampleTransformation="Nothing";
  }else if(SampleTransformation==SampleTransformationOptions[1]){
    SampleTransformation="Open";
  }else if(SampleTransformation==SampleTransformationOptions[2]){
    SampleTransformation="Close";
  }
  NbIteration=Dialog.getNumber();
  var NbIteration=round(NbIteration);

  if(isNaN(NbIteration)==1 || NbIteration<1 || NbIteration>50){ // Make sure the NbSelectedCh is a valid integer or display an error
    if(isNaN(NbIteration)==1){
      MessageError="Sorry but the Number of Iteration is not a number.";
    } else if(NbIteration<1){
      MessageError="Sorry but the Number of Iteration is too small.";
    } else if(NbIteration>50){
      MessageError="Sorry but the Number of Iteration is too big.";
    } else {
      MessageError="Sorry but the provided Number of Iteration is invalid.";
    }
    // Display an error
    MessageFix=MacroName+" function requires a positive Number of Iteration  comprised between 1 and 50.";
    ErrorResponseArray=newArray("Modify the Number of Iteration", "Cancel and Close");
    UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");

UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
    if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
      MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Number of Iteration was not comprised between 1 and 50.";
      CleanExit(MessageQuit);
    } else {
      SampleTransformationPromptPass=0;
    }
  } else {
    SampleTransformationPromptPass=1;
    return SampleTransformation+","+NbIteration;
    }
  } // End of function

function TransformSampleMultiple (ImageName, SampleTransformationArray){
  for (I=0; I<SampleTransformationArray.length; I++){
SampleTransformationNbIterationI=split(SampleTransformationArray[I],",");
SampleTransformationI=SampleTransformationNbIterationI[0];
NbIterationI=SampleTransformationNbIterationI[1];
//setBatchMode("show");
selectWindow(ImageName);
run("Options...", "iterations=&NbIterationI count=1 do=&SampleTransformationI");
}
}


function TransformSampleUnique (ImageName, SampleTransformation, NbIteration){
selectWindow(ImageName);
run("Options...", "iterations=&NbIteration count=1 do=&SampleTransformation");
}

var TryAgainMovePromptPass;
function TryAgainMovePrompt(ImageName){
  selectWindow(ImageName);
  setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
  run("Scale to Fit");
  setTool("zoom");
  waitForUser(PluginName+" Information","Look at the Image.\nYou may Zoom for a better view.\nTry Again or Move to Next Options will appear when OK is pressed.");

  TryAgainMovePromptPass=0;
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0, 0, 0);
  Dialog.addMessage("What would you like to do?");
  Dialog.addRadioButtonGroup("", newArray("Try Again", "Move to Next"), 2, 1, "Try Again");
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  TryAgainMovePromptChoice = Dialog.getRadioButton;
  if (TryAgainMovePromptChoice=="Move to Next") {
    TryAgainMovePromptPass=1;
  }
}



// This function Prompt for a specific type of selection and ensure a selection is made before moving next
var SelectionPromptPass; // This is the switch when the selection pass the criteria
function SelectionPrompt(SelectionTypeName, SelectionInfo){
  // Selection name is the name of the selection. It is a string that can take the following values:
  // rectangle, oval, polygon, freehand, traced, straight line, segmented line, freehandline, angle, point, multipoint
  // SelectionInfo is a string that explains what the Selection should be
  //SelectionPromptPass=0;
  // Define what the SelectionType value for each selection
  if(SelectionTypeName=="rectangle"){
    SelectionValue=0;
  } else if(SelectionTypeName=="oval"){
    SelectionValue=1;
  } else if(SelectionTypeName=="polygon"){
    SelectionValue=2;
  } else if(SelectionTypeName=="freehand"){
    SelectionValue=3;
  } else if(SelectionTypeName=="traced"){
    SelectionValue=4;
  } else if(SelectionTypeName=="straight line"){
    SelectionValue=5;
  } else if(SelectionTypeName=="segmented line"){
    SelectionValue=6;
  } else if(SelectionTypeName=="freehand line"){
    SelectionValue=7;
  } else if(SelectionTypeName=="angle"){
    SelectionValue=8;
  } else if(SelectionTypeName=="point"){
    SelectionValue=10;
  } else if(SelectionTypeName=="multipoint"){
    SelectionValue=10;
  } else {
    SelectionValue=-1; // No selection
  }

  CurrentImageName=getTitle(); // Get the Image of the Current Image
  CurrentSelection=selectionType(); // Get the Current selection

  // If the currentselection does not match the expected selection but if there is something in the overlay
  if(CurrentSelection!=SelectionValue && Overlay.size==1){
    run("Show Overlay");
    Overlay.activateSelection(0); // Get the selection from the overlay
    run("Remove Overlay");
    CurrentSelection=selectionType(); // refresh Current selection
  }

  if(CurrentSelection==SelectionValue && NbOfPoints==0){ // If a correct Selection is present ask what to do
    //setBatchMode("show");
    selectWindow(CurrentImageName);
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);

    MessageError="A "+SelectionTypeName+" selection was detected.";
    MessageFix="What would you like to do?";
    ErrorResponseArray=newArray("Keep the current "+SelectionTypeName+" selection", "Adjust the current "+SelectionTypeName+" selection", "Discard the current "+SelectionTypeName+" selection", "Cancel and Close");
    UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
  UserResponseErrorDialog=  ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
    if(UserResponseErrorDialog==ErrorResponseArray[0]){
      SelectionPromptPass=1;
    } else if(UserResponseErrorDialog==ErrorResponseArray[1]){
      SelectionPromptPass=0; // Set the Switch to 0
    } else if(UserResponseErrorDialog==ErrorResponseArray[2]) {
      run("Remove Overlay");
      run("Select None");
      SelectionPromptPass=0; // Set the Switch to 0
    }else if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]) {
      MessageQuit="Cancel and Close was Selected";
        CleanExit(MessageQuit);
    }

  } else { // Else the current selection does not match the expected selection
    SelectionPromptPass=0;
    if(NbOfPoints==0){
      run("Select None");

    }
  }

  if(SelectionPromptPass==0){ // If the selection is not set prompt or does not correspond to the expected selection
    //setBatchMode("show");
    selectWindow(CurrentImageName);
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
    run("Hide Overlay");
    setTool(SelectionTypeName);
    // if(SelectionTypeName=="multipoint"){
    //   setTool("multipoint");
    //   run("Point Tool...", "type=Hybrid color=White size=Large label show counter=0"); // Set the Point tool as yellow Medium Circle
    //   doCommand("Point Tool..."); // Bring the non-modal Point Tool at front in a separate thread
    // }
    call("ij.gui.WaitForUserDialog.setNextLocation", ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
      waitForUser(PluginName+" Information", "Draw a "+SelectionTypeName+" selection.\n"
    +SelectionInfo+
    "\nWhen done, press OK.");
    CurrentSelection=selectionType();
    if(CurrentSelection<0 || CurrentSelection!=SelectionValue){
      if(CurrentSelection<0){
        MessageError="Sorry but no "+SelectionTypeName+" selection was detected.";
        MessageFix=MacroName+" function requires a "+SelectionTypeName+" selection.";
        ErrorResponseArray=newArray("Create a "+SelectionTypeName+" selection", "Cancel and Close");
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because no "+SelectionTypeName+" was detected.";
      } else if(CurrentSelection!=SelectionValue){
        MessageError="Sorry but the Selection is not a "+SelectionTypeName+".";
        MessageFix=MacroName+" function requires a "+SelectionTypeName+" selection.";
        ErrorResponseArray=newArray("Create a "+SelectionTypeName+" selection", "Cancel and Close");
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the provided selection was not a "+SelectionTypeName+".";
      }
      //setBatchMode("show");

      // Close results windows if it is open
      if(isOpen("Results")){
        run("Clear Results");
        selectWindow("Results");        run("Close");

      }//end of if Results is open
      UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
UserResponseErrorDialog=ErrorDialog(MessageError,MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
      if(UserResponseErrorDialog==ErrorResponseArray[0]){
        run("Select None");
        SelectionPromptPass=0;
      } else if (UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
        CleanExit(MessageQuit);
      }
    } else {
      SelectionPromptPass=1;
      //setBatchMode("hide");

    }// End of else Selection is good
  } // End of If selection does not pass prompt for a selection
} // End of Function Get selection













// This function Prompt for a specific type of selection and ensure a selection is made before moving next
var SelectionPromptWithByPassPass; // This is the switch when the selection pass the criteria
var SelectionPromptWithByPassByPass; // This is a Logical object telling if the user deliberately exited the Selection Loop
function SelectionPromptWithByPassWithByPass(SelectionTypeName, SelectionInfo){
  // Selection name is the name of the selection. It is a string that can take the following values:
  // rectangle, oval, polygon, freehand, traced, straight line, segmented line, freehandline, angle, point, multipoint
  // SelectionInfo is a string that explains what the Seleciton should be
  //SelectionPromptWithByPassPass=0;
  // Define what the SelectionType value for each selection
  if(SelectionTypeName=="rectangle"){
    SelectionValue=0;
  } else if(SelectionTypeName=="oval"){
    SelectionValue=1;
  } else if(SelectionTypeName=="polygon"){
    SelectionValue=2;
  } else if(SelectionTypeName=="freehand"){
    SelectionValue=3;
  } else if(SelectionTypeName=="traced"){
    SelectionValue=4;
  } else if(SelectionTypeName=="straight line"){
    SelectionValue=5;
  } else if(SelectionTypeName=="segmented line"){
    SelectionValue=6;
  } else if(SelectionTypeName=="freehand line"){
    SelectionValue=7;
  } else if(SelectionTypeName=="angle"){
    SelectionValue=8;
  } else if(SelectionTypeName=="point"){
    SelectionValue=10;
  } else if(SelectionTypeName=="multipoint"){
    SelectionValue=10;
  } else {
    SelectionValue=-1; // No selection
  }

  CurrentImageName=getTitle(); // Get the Image of the Current Image
  CurrentSelection=selectionType(); // Get the Current selection

  // If the currentselection does not match the expected selection but if there is something in the overlay
  if(CurrentSelection!=SelectionValue && Overlay.size==1){
    run("Show Overlay");
    Overlay.activateSelection(0); // Get the selection from the overlay
    run("Remove Overlay");
    CurrentSelection=selectionType(); // refresh Current selection
  }

  if(CurrentSelection==SelectionValue){ // If a correct Selection is present ask what to do
    //setBatchMode("show");
    selectWindow(CurrentImageName);
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
    MessageError="A "+SelectionTypeName+" selection was detected.";
    MessageFix="What would you like to do?";
    ErrorResponseArray=newArray("Keep the current "+SelectionTypeName+" selection", "Adjust the current "+SelectionTypeName+" selection", "Discard the current "+SelectionTypeName+" selection", "Cancel and Close");
    MessageQuit="";
      UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
    UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray,UtilityWindowsToCloseArray);
    if(UserResponseErrorDialog==ErrorResponseArray[0]){
      SelectionPromptWithByPassPass=1;
    } else if(UserResponseErrorDialog==ErrorResponseArray[1]){
      run("Hide Overlay");
      SelectionPromptWithByPassPass=0; // Set the Switch to 0
    } else if(UserResponseErrorDialog==ErrorResponseArray[2]) {
      run("Remove Overlay");
      run("Select None");
      SelectionPromptWithByPassPass=0; // Set the Switch to 0
    }else if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]) {
      CleanExit(MessageQuit);
    }

  } else { // Else the current selection does not match the expected selection
    SelectionPromptWithByPassPass=0;
    run("Select None");
  }

  if(SelectionPromptWithByPassPass==0){ // If the selection is not set prompt or does not correspond to the expected selection
    //setBatchMode("show");
    selectWindow(CurrentImageName);
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
    run("Hide Overlay");
    setTool(SelectionTypeName);
    if(SelectionTypeName=="multipoint"){
      setTool("multipoint");
      run("Point Tool...", "type=Hybrid color=White size=Large label show counter=0"); // Set the Point tool as yellow Medium Circle
    }
    //If the Point Tool is not shown
    if(isOpen("Point Tool")!=1){
      doCommand("Point Tool..."); // Bring the non-modal Point Tool at front in a separate thread
    }
    selectWindow("Point Tool");
    setLocation(PointToolPosX,PointToolPosY);

    if(ImageChannels>1){
      Stack.setDisplayMode("grayscale");
    //run("16 Colors");
      //for(ChannelI=1; ChannelI<ImageChannels+1; ChannelI++){
        //Stack.setChannel(ChannelI);
        //wait(500);
      //}
      Stack.setChannel(1);
    } else {
      run("Grays");
    }
    //If the Brightness
    if(isOpen("B&C")!=1){
      run("Brightness/Contrast...");
    }
    selectWindow("B&C");
    setLocation(BCPosX,BCPosY);
    call("ij.gui.WaitForUserDialog.setNextLocation", ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
    waitForUser(PluginName+" Information", "Draw a "+SelectionTypeName+" selection.\n"
    +SelectionInfo+
    "\nWhen done, press OK.");
    CurrentSelection=selectionType();
    if(CurrentSelection<0 || CurrentSelection!=SelectionValue){
      if(CurrentSelection<0){
        // Dialog you did not make any selection are you sure?
        MessageError="Sorry but no "+SelectionTypeName+" selection was detected.";
        MessageFix="Do you want to proceed without selecting any Cell?";
        ErrorResponseArray=newArray("Proceed Without selecting any Cell", "Create a "+SelectionTypeName+" selection", "Cancel and Close");
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because no "+SelectionTypeName+" was detected.";
        if(isOpen("Results")){ run("Clear Results"); selectWindow("Results"); run("Close"); }// Close results windows if it is open

              UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
              UserResponseErrorDialog=ErrorDialog(MessageError,MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
        if(UserResponseErrorDialog==ErrorResponseArray[0]){
          SelectionPromptWithByPassPass=1;
          SelectionPromptWithByPassByPass=1;
        } else if(UserResponseErrorDialog==ErrorResponseArray[1]){
          SelectionPromptWithByPassPass=0;
          SelectionPromptWithByPassByPass=0;
        }  else if (UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
          CleanExit(MessageQuit);
        }
      } else if(CurrentSelection!=SelectionValue){
        MessageError="Sorry but the Selection is not a "+SelectionTypeName+".";
        MessageFix=MacroName+" function requires a "+SelectionTypeName+" selection.";
        ErrorResponseArray=newArray("Create a "+SelectionTypeName+" selection", "Cancel and Close");
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the provided selection was not a "+SelectionTypeName+".";
        if(isOpen("Results")){ run("Clear Results"); selectWindow("Results"); run("Close"); }// Close results windows if it is open
        //setBatchMode("show");
                      UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
        UserResponseErrorDialog=ErrorDialog(MessageError,MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
        if(UserResponseErrorDialog==ErrorResponseArray[0]){
          run("Select None");
          SelectionPromptWithByPassPass=0;
        } else if (UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
          CleanExit(MessageQuit);
        }
      }
    } else {
      SelectionPromptWithByPassPass=1;
      SelectionPromptWithByPassByPass=0;
      //setBatchMode("hide");

    }// End of else Selection is good
  } // End of If selection does not pass prompt for a selection
} // End of Function Get selection
////////////////////End of Functions

////////////////////End of Specific Functions



/////////////////////// Get or Set previous default values saved in the preferences file
// ProcessingMethod=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ProcessingMethod", "Global");// This is a coefficient used to compute the minimum and maximum particle diameter for each channel
//
// ROIMethodStatusString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ROIMethodStatusString", "0,0"); // Status of ROI detection methods. First one is Sample detection. Second one is manual selection of ROI. 1=selected; 0=ignored.
// ImageEnhancementOptionsString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ImageEnhancementOptionsString", "Remove Noise,Use Watershed"); // Status of ROI detection methods. First one is Sample detection. Second one is manual selection of ROI. 1=selected; 0=ignored.
//
// LowerSampleThreshold=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".LowerSampleThreshold", "0"); // Sample Threshold Values. First one is Lower Threshold, Second one is UpperThrehsold
// UpperSampleThreshold=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".UpperSampleThreshold", "0");
//
// ListChSelectionStatusString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChSelectionStatusString", "1,1,1,1,1,1,1"); // List of status for 5 channels. 1=selected; 0=ignored.
// ListChNameString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChNameString", "Ch1,Ch2,Ch3,Ch4,Ch5,Ch6,Ch7"); // List of name of 5 channels.
// ListChMinParticleDiameterString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChMinParticleDiameterString", "0,0,0,0,0,0,0"); // List of particle diameter for the 5 channels.
// ListChMaxParticleDiameterString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChMaxParticleDiameterString", "100,100,100,100,100,100,100"); // List of particle diameter for the 5 channels.
// ListChMinParticleCircularityString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChMinParticleCircularityString", "0,0,0,0,0,0,0"); // List of particle diameter for the 5 channels.
// ListChMaxParticleCircularityString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChMaxParticleCircularityString", "100,100,100,100,100,100,100"); // List of particle diameter for the 5 channels.
//
// ListChLowerThresholdString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChLowerThresholdString", "0,0,0,0,0,0,0"); // List of lower threshold for the 5 channels.
// ListChUpperThresholdString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChUpperThresholdString", "255,255,255,255,255,255,255"); // List of upper threshold for the 5 channels.
// ListChRemoveNoiseStatusString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChRemoveNoiseStatusString", "0,0,0,0,0,0,0");// Status of Remove Noise for each channel 1=selected; 0=ignored.
// ListChWatershedStatusString=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ListChWatershedStatusString", "0,0,0,0,0,0,0");// Status of Watershed for each channelds. 1=selected; 0=ignored.
//
//
// /////////////////////// Split the String from the preference file into Vectors
// ROIMethodStatus=split(ROIMethodStatusString,",");
// ImageEnhancementOptions=split(ImageEnhancementOptionsString,",");
// ListChSelectionStatus=split(ListChSelectionStatusString,",");
// ListChName=split(ListChNameString,",");
// ListChMinParticleDiameter=split(ListChMinParticleDiameterString,",");
// ListChMaxParticleDiameter=split(ListChMinParticleDiameterString,",");
// ListChMinParticleCircularity=split(ListChMinParticleCircularityString,",");
// ListChMaxParticleCircularity=split(ListChMaxParticleCircularityString,",");
// ListChLowerThreshold=split(ListChLowerThresholdString,",");
// ListChUpperThreshold=split(ListChUpperThresholdString,",");
// ListChRemoveNoiseStatus=split(ListChRemoveNoiseStatusString,",");
// ListChWatershedStatus=split(ListChWatershedStatusString,",");



InitialMessage=""+MacroName+" will :"
+"\n- Prompt to select a folder containing TIF images to be quantified"
+"\n- Prompt for:"
+"\n   - Channel selection"
+"\n   - Channel names"
+"\n   - Methods to define the Sample and ROI"
+"\n   - Image Enhancement Options"
+"\n   - Min and Max Cell Diameter"
+"\n   - Min and Max Cell Circuilarity Percentage"
+"\n- Open TIF images 1 by 1 from the selected folder"
+"\n- Process them with the defined parameters"
+"\n- Save the results in a new folder";

UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
MessageDialog(InitialMessage, UtilityWindowsToCloseArray); // Initial Dialog

do{ // Select Input Directory
  SelectInputDir(MinNbFile,FileExt);
}while(SelectInputDirPass!=1)


ProcessingMethod=call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".ProcessingMethod", "Global");
ProcessingMethodArray=newArray("Global","Individual");
ProcessingMethod=ProcessingMethodPrompt(ProcessingMethodArray,ProcessingMethod); // Select Processing Method
call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ProcessingMethod", ProcessingMethod);


if(ProcessingMethod=="Global") { // Check InputDir has Files with consistent number of CHannels for Global processing
  do{
    GlobalMethodPassInputDir=0;
    GetImageInfo(InputFileList);
    Array.getStatistics(NbChannelArray, MinNbCh, MaxNbCh, MeanNbCh, StDevNbCh);
    Array.getStatistics(NbSliceArray, MinNbSlice, MaxNbSlice, MeanNbSlice, StDevNbSlice);
    Array.getStatistics(NbFrameArray, MinNbFrame, MaxNbFrame, MeanNbFrame, StDevNbFrame);
    if(MinNbCh!=MaxNbCh || MaxNbSlice>1 || MaxNbFrame>1){
      if(MinNbCh!=MaxNbCh){
        MessageError="Sorry but the Folder:\n\"" +InputDirName+"\"\ncontains "+FileExt+" Files with inconsistent number of Channels (min:"+MinNbCh+", max:"+MaxNbCh+").";
        MessageFix="The "+ProcessingMethod+" Processing Method of "+MacroName+" requires a Folder that contains "+FileExt+" Files with the same nummber of Channels.";
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Folder:\n\"" +InputDirName+"\"\ndid not contain "+FileExt+" Files with the same Number of Channels.";
      } else {
        MessageError="Sorry but the Folder:\n\"" +InputDirName+"\"\ncontains "+FileExt+" Files with more than 3 dimensions (X, Y and Channels) ("+MaxNbSlice+" Slices; "+MaxNbSFrames+" Frames).";
        MessageFix=MacroName+" can't process Files with more than 3 dimensions (X, Y and Channels).";
        MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the Folder:\n\"" +InputDirName+"\"\n contained Files with more than 3 dimensions (X, Y and Channels) ("+MaxNbSlice+" Slices; "+MaxNbSFrames+" Frames).";
      }
      ErrorResponseArray=newArray("Select Another Folder", "Use Individual Processing Method", "Cancel and Close");

            UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
            UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray);
      if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
        CleanExit(MessageQuit);
      } else if (UserResponseErrorDialog==ErrorResponseArray[0]){
        do{
          SelectInputDir(MinNbFile,FileExt);
        }while(SelectInputDirPass!=1)
      } else if (UserResponseErrorDialog==ErrorResponseArray[1]){
        ProcessingMethod="Individual";
        GlobalMethodPassInputDir=1;
      }
    }else {GlobalMethodPassInputDir=1;}
  }while(GlobalMethodPassInputDir!=1)
}// End of Check InputDir has Files with consistent number of CHannels for Global processing

FolderSuffix=FolderSuffix+"-"+ProcessingMethod;

CreateOutputDir(ParentDir,InputDirName,FolderSuffix);
CreateOutputSubDir(SubDirArray);
OutputROIPath=""+OutputDirPath+"ROIs"+File.separator;
OutputResultPath=""+OutputDirPath+"Results"+File.separator;
OutputParameterPath=""+OutputDirPath+"Parameters"+File.separator;
OutputMeasurementPath=""+OutputDirPath+"Measurements"+File.separator;


// Start of the loop going through the list of files in the input folder selected above
for (FileI = 0; FileI < InputFileList.length; FileI++){
  //setBatchMode(true);
  InputFileNameI=InputFileList[FileI];
  BasenameArray=split(InputFileNameI,"."); // Array of Basename and File Extension
  InputFileNameINoExt=BasenameArray[0]; // Filename without extension
  InputFilePathI = InputDirPath+InputFileNameI; // Filepath
  open(InputFilePathI); // Open the first image

  getPixelSize(PixelUnit, PixelWidth, PixelHeight, PixelDepth);  // Get and Save the Scale
  ImageScale=1/PixelWidth; // Save the Scale as an object

  run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");   // Remove the scale to have coordinates in pixels since it is saved

  getDimensions(ImageWidth, ImageHeight, ImageChannels, ImageSlices, ImageFrames); // Get the dimension of the ImageSlices

  if(ImageSlices>1 && ImageFrames>1){ // If the image has more than 1 slice or 1 frame
//Create the Variables to be used by the errordialog
    MessageError="Sorry but the File:\n\"" +InputFileNameI+"\"\ has "+ImageSlices+" slices and "+ImageFrames+" frames.";
    MessageFix=MacroName+" can't process Files with more than 3 dimensions (X, Y and Channels).";
    "Process a specific Slice/Frame", "Process the Maximum Intensity Projection", "Cancel & Close"
    ErrorResponseArray=newArray("Process a specific Slice/Frame", "Process the Maximum Intensity Projection","Ignore this File", "Cancel and Close");
    MessageQuit=PluginName+ " Information:\nThe function "+ MacroName+" stopped because the File:\n\"" +InputFileNameI+"\"\nhad more than 3 dimensions (X, Y and Channels).";

    //setBatchMode("show");
    selectWindow(InputFileNameI);
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
                UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
    UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray, UtilityWindowsToCloseArray); // Display the ErrorDialog
    // Process user response to error
    if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
      CleanExit(MessageQuit);
    } else if (UserResponseErrorDialog=="Ignore this File") {
      // Move to the Next File to be implemented
    } else if (UserResponseErrorDialog=="Process the Maximum Intensity Projection"){
      //setBatchMode("hide");
      selectWindow(InputFileNameI);
      run("Z Project...", "projection=[Max Intensity]");
      selectWindow(InputFileNameI);      close(); // Close the previous Window
      selectWindow("MAX_"+InputFileNameI);       rename(InputFileNameI); // Rename the MIP
    } else if (UserResponseErrorDialog=="Process a specific Slice/Frame"){
      //setBatchMode("show");
      selectWindow(InputFileNameI);
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      call("ij.gui.WaitForUserDialog.setNextLocation", ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
      waitForUser(PluginName+" Information", "Move to the Slice/Frame you would like to process."
      +"\nWhen done, press OK.");
      //setBatchMode("hide");
      selectWindow(InputFileNameI);
      getDimensions(ImageWidth, ImageHeight, ImageChannels, ImageSlices, ImageFrames); // Refresh the Image dimension
      Stack.getPosition(CurrentChannel, CurrentSlice, CurrentFrame); // Get the position
      SubStackString=""+"channels=1-"+ImageChannels+" slices="+CurrentSlice+" frames="+CurrentFrame; // Make a substack keeping the channels but with 1 slice and 1 frame
      run("Make Substack...", SubStackString); // Make the Substack
      selectWindow(InputFileNameI);       close(); // Close the original file
      selectWindow(InputFileNameINoExt+"-1.tif");       rename(InputFileNameI); // Rename the newly made Image
    }// end of process user response
  }// End of Check Input File dimensions

  // Select the Channels and indicate the Channel Names
  do{
    if(ProcessingMethod=="Global" && FileI>0){ // If Process is Global and if it is not the first file then bypass the SelectChannel Prompt
      SelectChannelPass=1;
      //setBatchMode("hide");
    } else { // If Method is individual or if it is the first file prompt to select the channel
      //setBatchMode("show");
      selectWindow(InputFileNameI);
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      SelectChannel(InputFileNameI, 1, 7);
    }
  } while(SelectChannelPass!=1)

  //////////////////////////////// Create a new array with only the selected Ch
  ListSelectedCh=newArray(0); // This is the List of Channels that are selected
  ListDroppedCh= newArray(0);
  for(ChI=0; ChI < ImageChannels; ChI++){
    if(ListChSelectionStatus[ChI]==1){
      ListSelectedCh=Append(ListSelectedCh,ChI+1);//We add 1 for making a list of Ch number from 1 to 7 and not 0 to 6
    } else if (ListChSelectionStatus[ChI]==0){
      ListDroppedCh=Append(ListDroppedCh, ChI+1);
    }
  }// End of For ChI populate the ListofSelect Ch or DroppedCH

  // Duplicate the Opened Image and save it as an Original it will be used at the end to get the Measurements
  selectWindow(InputFileNameI); //  This is the image we are using as a source for other things it will be rescaled to have a nice um unit
  run("Duplicate...", "title=Original duplicate");// This is exactly the original picture

  // Create Parameter Files
  ParameterTXTFileName=""+InputDirName+"_"+"Parameters";
  ParameterTXTFilePath=OutputDirPath+ParameterTXTFileName+".txt";
  ParameterTXTFile = File.open(ParameterTXTFilePath);
  print(ParameterTXTFile, "Filename"+CellSeparator+"ROI"+CellSeparator+"Parameter"+CellSeparator+"Value"+LineSeparator);
  File.close(ParameterTXTFile);
  File.append("All Files"+CellSeparator+"All ROIs"+CellSeparator+"Processing Method"+CellSeparator+ProcessingMethod, ParameterTXTFilePath);
  File.append(InputFileNameINoExt+CellSeparator+"Whole Image"+CellSeparator+"Resolution (pixels per "+PixelUnit+")"+CellSeparator+ImageScale, ParameterTXTFilePath);
  File.append(InputFileNameINoExt+CellSeparator+"Whole Image"+CellSeparator+"Image Width (pixels)"+CellSeparator+ImageWidth, ParameterTXTFilePath);
  File.append(InputFileNameINoExt+CellSeparator+"Whole Image"+CellSeparator+"Image Height (pixels)"+CellSeparator+ImageHeight, ParameterTXTFilePath);
  File.append(InputFileNameINoExt+CellSeparator+"Whole Image"+CellSeparator+"Image Area (pixels^2)"+CellSeparator+ImageWidth*ImageHeight, ParameterTXTFilePath);

  // Duplicate InputFIleNamei and Remove the Unused Channels and call it SelectedChannels
  //setBatchMode("hide");

  for(SelectedChI=0; SelectedChI<ListSelectedCh.length; SelectedChI++){
    if(SelectedChI==0){
      SelectedChString="channels="+ListSelectedCh[SelectedChI];
    } else {
      SelectedChString=SelectedChString+","+ListSelectedCh[SelectedChI];
    }
  }// End of create SubstackString

  selectWindow(InputFileNameI);
  run("Make Substack...", SelectedChString);
  rename("SelectedChannels");

  // Work to identify the sample if Auto detect Sample is ON
  if(AutoSampleDetection==1){
    selectWindow("SelectedChannels");
    run("Duplicate...", "title=Sample duplicate");// This is the sample
    selectWindow("Sample");
    if(NbSelectedCh>1){
      run("Z Project...", "title=MIP projection=[Max Intensity]");
      selectWindow("Sample");
      close();
      selectWindow("MAX_Sample");
      rename("Sample");
      run("Grays");
      // This is the Maximum Intensity projection of the image used to detect the sample contour
    }else{ // If only 1 Channels then convert to gray
      run("Grays");
    }
    // From here we have a gray Sample 1 Ch

    if(ProcessingMethod=="Global" && FileI>0){ // If process is Global
      //setBatchMode("hide");
      selectWindow("Sample");
      setThreshold(LowerSampleThreshold, UpperSampleThreshold);
      run("Convert to Mask");
    }else{
      selectWindow("Sample");// We convert the Sample to binary for a mask
      //setBatchMode("show");
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      // These lines are if you want to bring up threshold values from previous files It causes issues with 16bits images
      // setThreshold(LowerSampleThreshold,UpperSampleThreshold);
      setAutoThreshold("Default dark");
      run("Threshold...");
      waitForUser(PluginName+" Information", "Adjust the Threshold to identify all your SAMPLE."
      +"\nWhen done, press OK.");
      getThreshold(LowerSampleThreshold, UpperSampleThreshold);
      //setBatchMode("hide");
      selectWindow("Sample");// We convert the Sample to binary for a mask
      setThreshold(LowerSampleThreshold, UpperSampleThreshold);
      run("Convert to Mask");
      resetThreshold();
      run("Scale to Fit");

      if(isOpen("Threshold")){selectWindow("Threshold");      run("Close");}
    } // end of else if process is individual
    // From Here Sample Image has been Thresholded
    /////////////////////// Process the binary Mask to cover all the tissue


SampleTransformationString = call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".SampleTransformationString", "None,1");
SampleTransformationArray=split(SampleTransformationString, "\t");
SampleTransformationNbIteration=split(SampleTransformationArray[0],",");
SampleTransformation=SampleTransformationNbIteration[0];
NbIteration=SampleTransformationNbIteration[1];


    do{
      SampleTransformationString = call("ij.Prefs.get", "Default."+PluginName+"."+MacroName+".SampleTransformationString", "None,1");
SampleTransformationArray=split(SampleTransformationString, "\t");
SampleTransformationNbIteration=split(SampleTransformationArray[0],",");
SampleTransformation=SampleTransformationNbIteration[0];
NbIteration=SampleTransformationNbIteration[1];

SampleTransformationString=    SampleTransformationPrompt(SampleTransformation, NbIteration);
SampleTransformationArray=split(SampleTransformationString, "\t");
SampleTransformationNbIteration=split(SampleTransformationArray[0],",");
SampleTransformation=SampleTransformationNbIteration[0];
NbIteration=SampleTransformationNbIteration[1];

    TransformSampleUnique("Sample", SampleTransformation, NbIteration);
    TryAgainMovePrompt("Sample");
    } while(TryAgainMovePromptPass!=1)

    SampleTransformationNbIteration="Nothing"+","+1;
    SampleTransformationArray=Append(SampleTransformationArray,SampleTransformationNbIteration);
    TransformSampleUnique("Sample", "Nothing", 1);

waitForUser("TOTO");

    // Create a selection to be added to the ROI
    selectWindow("Sample");
    run("Create Selection");
    CurrentSelection=selectionType();  // Get the Selection
    if(CurrentSelection==4 || CurrentSelection<0) { // No selection was made

selectWindow("Sample");
run("Select None");
run("Select All");// If it is then select all
      }

    // Write the Threshold Values in the preferences Only if Sample was Selected
    call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".LowerSampleThreshold",LowerSampleThreshold);
    call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".UpperSampleThreshold",UpperSampleThreshold);
    for(I=0; I<SampleTransformationArray.length; I++){
      if(I==0){
        SampleTransformationString=""+SampleTransformationArray[I];
    } else {
      SampleTransformationString=SampleTransformationString+"\t"+SampleTransformationArray[I];
    }
    }
        call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".SampleTransformationString", SampleTransformationString);

    // Save the Selection into the ROI manager
    roiManager("reset");
    selectWindow("Sample");
    roiManager("Add");
    roiManager("Select", 0);
    roiManager("Rename", "Sample");
    selectWindow("Sample"); // We have the ROI of the sample in the ROI manager so we can close the window
    close();

  } else { // End of if Sample should be detected. so if sample is NOT detected
    LowerSampleThreshold="No Sample detection"; // To be written in the parameters
    UpperSampleThreshold="No Sample detection";
  }// End of IF Sample is Not detected
  File.append(InputFileNameINoExt+CellSeparator+"Whole Image"+CellSeparator+"Lower Sample Threshold"+CellSeparator+LowerSampleThreshold, ParameterTXTFilePath);
  File.append(InputFileNameINoExt+CellSeparator+"Whole Image"+CellSeparator+"Upper Sample Threshold"+CellSeparator+UpperSampleThreshold, ParameterTXTFilePath);

  // Work on the Manual ROI
  if(ManualSampleDetection==1){
    selectWindow("SelectedChannels");
    run("Duplicate...", "title=RegionOfInterest duplicate");// This is the sample
    selectWindow("RegionOfInterest");
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);

    if(ProcessingMethod=="Global" && FileI>0){ // If process is global then Use the Sample as a ROI
      //setBatchMode("hide");
      if(AutoSampleDetection==0){ // If sample was not defined earlier
        selectWindow("RegionOfInterest");
        run("Select None");
        run("Select All");
      } else { // If sample was defined earlier
        // Use the previous ROI and copy it
        selectWindow("RegionOfInterest");
        NbROI=roiManager("count");
        run("Select None");
        roiManager("Select", NbROI-1);
      } // End of if sample was not defined earlier
    } else { // end of if process is global so if process is individual
      if(AutoSampleDetection==0){ // If sample was not defined earlier then prompt to draw a selection
        selectWindow("RegionOfInterest");
        run("Select None"); // deselect any pre selection
        setTool("freehand");
    waitForUser(PluginName+" Information", "Please, use a Selection Tool to Select the Region of Interest (ROI).\nWhen done press OK.");
        CurrentSelection=selectionType();
        if(CurrentSelection<0){
          do {
            SelectionPass=0;
            if(isOpen("Threshold")){                    selectWindow("Threshold");                    run("Close");}
            selectWindow("RegionOfInterest");
            run("Select None");
            setTool("freehand");
            call("ij.gui.ImageWindow.setNextLocation", ThresholdPosX,ThresholdPosY+ThresholdSizeY+Spacer);
            waitForUser(PluginName+" Information", "The Region of Interest (ROI) could not be detected.\nPlease use a Selection Tool to Select the Region of Interest (ROI).\nWhen done press OK.");
            CurrentSelection=selectionType();
            // Ensure a selection is provided
            if(CurrentSelection<0){
              Dialog.create(PluginName+" Information");
              Dialog.setInsets(0, 0, 0);
              Dialog.addMessage("Sorry but no selection has been detected."
              +"\nUse a Selection Tool to Select the Region of Interest (ROI).");
              UserChoiceArray=newArray("Try Again", "Cancel & Close");
              Dialog.setInsets(0, 80, 0);
              Dialog.addRadioButtonGroup("", UserChoiceArray, 2,1, "Try Again");
              Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+Spacer+15);
              Dialog.show();
              UserChoice=Dialog.getRadioButton();
              if (UserChoice=="Cancel & Close"){
                exit(PluginName+" has stopped because no Region of Interest (ROI) Selection was provided.");
              }
            }else {SelectionPass=1;}
          } while(SelectionPass!=1) // end of ensure a Selection
        }
      } else { // end of if sample was not defined earlier so Sample WAS actually then prompt to ADJUST the previous selection
        if(isOpen("Threshold")){                  selectWindow("Threshold");                  run("Close");}
        selectWindow("RegionOfInterest");
        //setBatchMode("show");
        selectWindow("RegionOfInterest");
        setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
        selectWindow("RegionOfInterest");
        NbROI=roiManager("count");
        run("Select None");
        roiManager("Select", NbROI-1);
        setTool("freehand");
        call("ij.gui.ImageWindow.setNextLocation", ThresholdPosX,ThresholdPosY+ThresholdSizeY+Spacer);
        waitForUser(PluginName+" Information", "If necessary, Adjust the Current Region of Interest (ROI).\nUse\nShift+Click & Drag to ADD\nor\nOption+Click & Drag to SUBTRACT to the Current Selection\nWhen done press OK.");
        CurrentSelection=selectionType();

        if(CurrentSelection<0){
          do {
            SelectionPass=0;
            if(isOpen("Threshold")){                        selectWindow("Threshold");                        run("Close");}
            selectWindow("RegionOfInterest");
            run("Select None");
            setTool("freehand");
            call("ij.gui.ImageWindow.setNextLocation", ThresholdPosX,ThresholdPosY+ThresholdSizeY+Spacer);
            waitForUser(PluginName+" Information", "The Region of Interest (ROI) could not be detected.\nPlease use a Selection Tool to Select the Region of Interest (ROI).\nWhen done press OK.");
            CurrentSelection=selectionType();
            // Ensure a selection is provided
            if(CurrentSelection<0){
              Dialog.create(PluginName+" Information");
              Dialog.setInsets(0, 0, 0);
              Dialog.addMessage("Sorry but no Selection has been detected."
              +"\nUse a Selection Tool to Select the Region of Interest (ROI).");
              UserChoiceArray=newArray("Try Again", "Cancel & Close");
              Dialog.setInsets(0, 80, 0);
              Dialog.addRadioButtonGroup("", UserChoiceArray, 2,1, "Try Again");
              Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+Spacer+15);
              Dialog.show();
              UserChoice=Dialog.getRadioButton();
              if (UserChoice=="Cancel & Close"){
                exit(PluginName+" has stopped because no Region of Interest (ROI) Selection was provided.");
              }
            }else {SelectionPass=1;}
          } while(SelectionPass!=1) // end of ensure a Selection
        }// end of if Current Selection
      } // end of else Sample WAS actually defined earlier prompt to adjust
    }// end of if Process is NOT global so it is individual then prompt
    // From now we should have a ROI Selection
    //setBatchMode("hide");
    selectWindow("RegionOfInterest");
    roiManager("Add");
    NbROI=roiManager("count");
    run("Select None");
    roiManager("Select", NbROI-1);
    roiManager("Rename", "Manual_Sample");
    selectWindow("RegionOfInterest");
    close();
  } else { // ENd of if Manual ROI is selected
    //Do nothing
  } // end of If Manual ROI is NOT selected
  setForegroundColor(255, 255, 255);
  setBackgroundColor(0, 0, 0);// Set the foreground and background colors
  // if a ROI was defined Sample OR Manual then clear outside the last made ROI
  if(AutoSampleDetection==1 || ManualSampleDetection==1){
    //setBatchMode("hide");
    setForegroundColor(255, 255, 255);
    setBackgroundColor(0, 0, 0);// Set the foreground and background colors
    selectWindow(InputFileNameI); // InputFileName has all the original channels and is cropped on the sample or on the ROI
    NbROI=roiManager("count");
    run("Select None");
    roiManager("Select", NbROI-1);
    run("Clear Outside");
  }
  //setBatchMode("hide");
  selectWindow("SelectedChannels"); // SelectedChannels has only the Selected Channels and is cropped on the sample or on the ROI
  close();




waitForUser("TATA");

  ///////////////////////////////////////////// Duplicate and threshold the each selected channels
  for (ChI=0; ChI < ListSelectedCh.length; ChI++){
    //setBatchMode("hide");
    SelectedChI=ListSelectedCh[ChI]; //This is the number of the selected channels >=1 it can be above 5 if user select only channel 2 and 7 for example.
    SelectedChIListPos=SelectedChI-1; // This is the position within the array of the SelectedChI
    NameSelectedChI=ListChName[SelectedChIListPos]; // This is the Name of the Selected Channels
    LowerThresholdSelectedChI=ListChLowerThreshold[SelectedChIListPos]; // This is the LowerThreshold for the Channel I
    UpperThresholdSelectedChI=ListChUpperThreshold[SelectedChIListPos];// This is the UpperThreshold for the Channel I
    RemoveNoiseStatusSelectedChI=ListChRemoveNoiseStatus[SelectedChIListPos]; // This is 1 or 0 if we apply or not Remove Noise function
    WatershedStatusSelectedChI=ListChWatershedStatus[SelectedChIListPos];// This is 1 or 0 if we apply or not Watershed function
    MinParticleDiameterSelectedChI=ListChMinParticleDiameter[SelectedChIListPos]; // This is the particle diameter in Unit^2 for ChI
    MaxParticleDiameterSelectedChI=ListChMaxParticleDiameter[SelectedChIListPos]; // This is the  percentage of variation allowed around the particle diameterfor ChI
    MinParticleCircularitySelectedChI=ListChMinParticleCircularity[SelectedChIListPos]; // This is the particle diameter in Unit^2 for ChI
    MaxParticleCircularitySelectedChI=ListChMaxParticleCircularity[SelectedChIListPos]; // This is the particle diameter in Unit^2 for ChI

    selectWindow(InputFileNameI);
    run("Select None");
    run("Remove Overlay");
    call("ij.gui.ImageWindow.setNextLocation", IJPosX,IJPosY+IJSizeY+Spacer)
    run("Duplicate...", "duplicate title=&NameSelectedChI channels=&SelectedChI"); // Duplicate each channel to threshold
    selectWindow(NameSelectedChI);
    run("Grays");
    // This is to bring the threshold from the preferences but cause bugs in 16bits image
    // setThreshold(LowerThresholdSelectedChI,UpperThresholdSelectedChI);

    if(ProcessingMethod=="Global" && FileI>0){
      //setBatchMode("hide");
      selectWindow(NameSelectedChI);
      // Threshold the Image
      setThreshold(LowerThresholdSelectedChI, UpperThresholdSelectedChI);
      run("Convert to Mask");
      // Apply the Image Enhancements
      if(RemoveNoiseStatusSelectedChI==1 && WatershedStatusSelectedChI==0){
        run("Open");
      } else if(RemoveNoiseStatusSelectedChI==0 && WatershedStatusSelectedChI==1){
        run("Watershed");
      } else if(RemoveNoiseStatusSelectedChI==1 && WatershedStatusSelectedChI==1){
        run("Open");
        run("Watershed");
      }
      // Calculate the Particle Area
      MinParticleAreaSelectedChI=PI*MinParticleDiameterSelectedChI*MinParticleDiameterSelectedChI;
      MaxParticleAreaSelectedChI=PI*MaxParticleDiameterSelectedChI*MaxParticleDiameterSelectedChI;
      // Convert the circularity percentage into a decimal
      MinParticleCircularitySelectedChIDecimal = 0.01*MinParticleCircularitySelectedChI;
      MaxParticleCircularitySelectedChIDecimal = 0.01*MaxParticleCircularitySelectedChI;
      // Analyze Particle for saving as an Overlay
      selectWindow(NameSelectedChI);
      run("Select None");
      run("Remove Overlay");
      run("Analyze Particles...", "size=&MinParticleAreaSelectedChI-&MaxParticleAreaSelectedChI circularity=&MinParticleCircularitySelectedChIDecimal-&MaxParticleCircularitySelectedChIDecimal show=[Overlay Masks] in_situ");
      run("Overlay Options...", "stroke=magenta width=1 fill=cyan apply show");
      run("Labels...", "color=blue font=10 show bold");

    } else { // If processing is not Global
      // These lines are if you want to bring up threshold values from previous files It causes issues with 16bits images
      // setThreshold(LowerThresholdSelectedChI,UpperThresholdSelectedChI);
      selectWindow(NameSelectedChI);
      //setBatchMode("show");
      selectWindow(NameSelectedChI);
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      setAutoThreshold("Default dark");
      run("Threshold...");
      setTool("zoom");
      waitForUser(PluginName+" Information", "Adjust the Threshold to identify your staining for "+NameSelectedChI+"."
      +"\nWhen done, press OK.");
      //setBatchMode("hide");
      getThreshold(LowerThresholdSelectedChI, UpperThresholdSelectedChI);
      // Update the List of Threshold
      ListChLowerThreshold[SelectedChIListPos]=LowerThresholdSelectedChI;
      ListChUpperThreshold[SelectedChIListPos]=UpperThresholdSelectedChI;
      selectWindow(NameSelectedChI);
      run("Convert to Mask");
      if(isOpen("Threshold")){                    selectWindow("Threshold");                    run("Close");}
      selectWindow(NameSelectedChI);
      run("Duplicate...", "title=RemoveNoise duplicate");
      run("Open");
      selectWindow(NameSelectedChI);
      run("Duplicate...", "title=Watershed duplicate");
      run("Watershed");
      selectWindow(NameSelectedChI);
      run("Duplicate...", "title=RemoveNoise_AND_Watershed duplicate");
      run("Open");
      run("Watershed");
      ImageEnhancementName="Image Enhancement Options for "+NameSelectedChI;
      run("Concatenate...", "  title=&ImageEnhancementName image1=&NameSelectedChI image2=RemoveNoise image3=Watershed image4=RemoveNoise_AND_Watershed image5=[-- None --]");
      selectWindow(ImageEnhancementName);
      // This set up the slice of the previously choosen options
      if(RemoveNoiseStatusSelectedChI==1 && WatershedStatusSelectedChI==0){
        setSlice(2);
      } else if(RemoveNoiseStatusSelectedChI==0 && WatershedStatusSelectedChI==1){
        setSlice(3);
      } else if(RemoveNoiseStatusSelectedChI==1 && WatershedStatusSelectedChI==1){
        setSlice(4);
      } else {
        setSlice(1);
      }
      resetThreshold();
      if(isOpen("Threshold")){                      selectWindow("Threshold");                      run("Close");
    }
    setTool("zoom");
    selectWindow(ImageEnhancementName);
    resetThreshold();
    //setBatchMode("show");
    selectWindow(ImageEnhancementName);
    setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
    call("ij.gui.ImageWindow.setNextLocation", ThresholdPosX,ThresholdPosY+ThresholdSizeY+Spacer);
    waitForUser(PluginName+" Information", "Select the optimal Image for "+NameSelectedChI+".\nYou may Zoom for a better view.\nSlice 1: Original\nSlice 2: Noise Removed\nSlice 3: Watershed\nSlice 4: Noise Removed & Wateshed"
    +"\nWhen done, press OK.");
    //setBatchMode("hide");
    selectWindow(ImageEnhancementName);
    getDimensions(ImageWidthEnhancement, ImageHeightEnhancement, NbChannelsEnhancement, NbSlicesEnhancement, NbFramesEnhancement); // Get dimensions of the Image
    Stack.getPosition(CurrentChannelEnhancement, CurrentSliceEnhancement, CurrentFrameEnhancement);
    // Delete the other Slices
    SubStackString=""+"channels=1-"+NbChannelsEnhancement+" slices="+CurrentSliceEnhancement+" frames="+CurrentFrameEnhancement;
    selectWindow(ImageEnhancementName);
    run("Select None");
    run("Make Substack...", SubStackString);
    rename(NameSelectedChI);
    selectWindow(ImageEnhancementName);
    close();
    if(CurrentSliceEnhancement==2){
      RemoveNoiseStatusSelectedChI=1;
      WatershedStatusSelectedChI=0;
    }else if(CurrentSliceEnhancement==3){
      RemoveNoiseStatusSelectedChI=0;
      WatershedStatusSelectedChI=1;
    }else if(CurrentSliceEnhancement==4){
      RemoveNoiseStatusSelectedChI=1;
      WatershedStatusSelectedChI=1;
    } else {
      RemoveNoiseStatusSelectedChI=0;
      WatershedStatusSelectedChI=0;
    }
    // Update the Enhancement Status
    ListChRemoveNoiseStatus[SelectedChIListPos]=RemoveNoiseStatusSelectedChI;
    ListChWatershedStatus[SelectedChIListPos]=WatershedStatusSelectedChI;


    // From Now we have selected the Enhancement option for Selected Ch and have a binary Image

    do {
      SelectionPass=0;
      if(isOpen("Threshold")){                        selectWindow("Threshold");                        run("Close");}
      setTool("wand");//Select wand tool
      selectWindow(NameSelectedChI);
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      //setBatchMode("show");
      selectWindow(NameSelectedChI);
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      call("ij.gui.ImageWindow.setNextLocation", ThresholdPosX,ThresholdPosY+ThresholdSizeY+Spacer);
      waitForUser(PluginName+" Information", "Select the Largest Cell you would like to count for "+NameSelectedChI+"."
      +"\nWhen done, press OK.");
      CurrentSelection=selectionType();

      if(CurrentSelection<0 || CurrentSelection>5){
        Dialog.create(PluginName+" Information");
        Dialog.setInsets(0, 0, 0);
        Dialog.addMessage("Sorry but no selection has been detected."
        +"\nUse a Selection Tool to Select the Largest Cell\nyou would like to count for "+NameSelectedChI+".");
        UserChoiceArray=newArray("Try Again", "Cancel & Close");
        Dialog.setInsets(0, 80, 0);
        Dialog.addRadioButtonGroup("", UserChoiceArray, 2,1, "Try Again");
        Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+Spacer+15);
        Dialog.show();
        UserChoice=Dialog.getRadioButton();
        if (UserChoice=="Cancel & Close"){
          exit(PluginName+" has stopped because no selection was provided for "+NameSelectedChI+".");
        }
      }else {SelectionPass=1;}
    } while(SelectionPass!=1)

    //setBatchMode("hide");
    // Once a selection is Made get the area of the selection
    run("Set Measurements...", "area mean standard modal min centroid center perimeter bounding fit shape feret's integrated median skewness kurtosis area_fraction stack display invert redirect=None decimal=9");
    //run("Clear Results");

    run("Measure");
    ParticleAreaChIMeasured=getResult("Area", nResults-1);
    //run("Clear Results");
    IJ.deleteRows(nResults-1,nResults-1);
    selectWindow(NameSelectedChI);
    run("Select None");
    // From the area calculate the diameter of the Particle
    ParticleDiameterChIMeasured=round(2*sqrt(ParticleAreaChIMeasured/PI));
    // Set up the Min and Max Particle diameter and circularity
    MinParticleDiameterSelectedChI=0;
    MaxParticleDiameterSelectedChI=ParticleDiameterChIMeasured;
    MinParticleCircularitySelectedChI=0;
    MaxParticleCircularitySelectedChI=100;

    // Prompt for Parameter adjustments
    do{
      // Calculate the Min and Max ParticleArea from the Diameter
      MinParticleAreaSelectedChI=PI*MinParticleDiameterSelectedChI*MinParticleDiameterSelectedChI;
      MaxParticleAreaSelectedChI=PI*MaxParticleDiameterSelectedChI*MaxParticleDiameterSelectedChI;
      // Convert the circularity percentage into a decimal
      MinParticleCircularitySelectedChIDecimal=0.01*MinParticleCircularitySelectedChI;
      MaxParticleCircularitySelectedChIDecimal=0.01*MaxParticleCircularitySelectedChI;

      // Do a first analysis particle and save it as OverlayMask
      selectWindow(NameSelectedChI);
      run("Select None");// Remove any selection
      run("Remove Overlay");
      run("Analyze Particles...", "size=&MinParticleAreaSelectedChI-&MaxParticleAreaSelectedChI circularity=&MinParticleCircularitySelectedChIDecimal-&MaxParticleCircularitySelectedChIDecimal show=[Overlay Masks] in_situ");
      run("Overlay Options...", "stroke=magenta width=1 fill=cyan apply show");
      run("Labels...", "color=blue font=10 show bold");
      if(isOpen("Threshold")){                          selectWindow("Threshold");                          run("Close");}
      setTool("zoom");
      selectWindow(NameSelectedChI);
      //setBatchMode("show");
      selectWindow(NameSelectedChI);
      setLocation(IJPosX, IJPosY+IJSizeY+Spacer, IJSizeX, screenHeight*0.75);
      waitForUser(PluginName+" Information","Look at the Cell Detection (Cyan Overlay).\nYou may Zoom for a better view.\nCell Detection Parameters will appear when OK is pressed.");

      do{
        DialogPass=0;
        ParticleDetectionPass=0;
        Dialog.create(PluginName+" Information");
        Dialog.setInsets(0, 0, 0);
        Dialog.addMessage("Adjust the Cell Detection Parameters for "+NameSelectedChI+" and Try Again.");
        Dialog.setInsets(0, 0, 0);
        Dialog.addMessage("or Move to Next.");
        Dialog.setInsets(0, 0, 0);
        Dialog.addNumber("Min Cell Diameter for "+NameSelectedChI+" :", MinParticleDiameterSelectedChI, 0, 10, RescaledUnit)
        Dialog.setInsets(0, 0, 0);
        Dialog.addNumber("Max Cell Diameter for "+NameSelectedChI+" :", MaxParticleDiameterSelectedChI, 0, 10, RescaledUnit)
        Dialog.setInsets(0, 0, 0);
        Dialog.addSlider("Min Cell Circularity for "+NameSelectedChI+" :", 0, 100, MinParticleCircularitySelectedChI);
        Dialog.setInsets(0, 0, 0);
        Dialog.addSlider("Max Cell Circularity for "+NameSelectedChI+" :", 0, 100, MaxParticleCircularitySelectedChI);
        Dialog.setInsets(0, 0, 0);
        UserChoiceDetectionArray=newArray("Try Again", "Move to Next");
        Dialog.setInsets(0, 150, 0);
        Dialog.addRadioButtonGroup("", UserChoiceDetectionArray, 2, 1, "Try Again");
        Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+Spacer+15);
        Dialog.show();

        MinParticleDiameterSelectedChI=Dialog.getNumber();
        MaxParticleDiameterSelectedChI=Dialog.getNumber();
        MinParticleCircularitySelectedChI=Dialog.getNumber();
        MaxParticleCircularitySelectedChI=Dialog.getNumber();
        UserChoiceDetection=Dialog.getRadioButton();
        // Reorder Particle Diameter if smaller is larger
        if(MinParticleDiameterSelectedChI>MaxParticleDiameterSelectedChI){
          ParticleDiameterTemporary=MaxParticleDiameterSelectedChI;
          MaxParticleDiameterSelectedChI=MinParticleDiameterSelectedChI;
          MinParticleDiameterSelectedChI=ParticleDiameterTemporary;
        }
        // Reorder Particle Circularity if smaller is larger
        if(MinParticleCircularitySelectedChI>MaxParticleCircularitySelectedChI){
          ParticleCircularityTemporary=MinParticleCircularitySelectedChI;
          MaxParticleCircularitySelectedChI=MinParticleCircularitySelectedChI;
          MinParticleCircularitySelectedChI=ParticleCircularityTemporary;
        }

        // Ensure Particle Diameter entered are numeric and positive
        if(isNaN(MinParticleDiameterSelectedChI)||isNaN(MaxParticleDiameterSelectedChI)|| MinParticleDiameterSelectedChI<0){
          Dialog.create(PluginName+" Information");
          Dialog.setInsets(0, 0, 0);
          if(isNaN(MinParticleDiameterSelectedChI)){
            Dialog.addMessage("Sorry but the Min Particle Diameter must be a number.");
          }else if (isNaN(MaxParticleDiameterSelectedChI)) {
            Dialog.addMessage("Sorry but the Max Particle Diameter must be a number.");
          } else {
            Dialog.addMessage("Sorry but the Min Particle Diameter can't be smaller than 0.");
          }
          Dialog.setInsets(0, 0, 0);
          UserChoiceArray=newArray("Try Again", "Cancel & Close");
          Dialog.setInsets(0, 50, 0);
          Dialog.addRadioButtonGroup("", UserChoiceArray, 2, 1, "Try Again");
          Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+Spacer+15);
          Dialog.show();
          UserChoice=Dialog.getRadioButton();
          if (UserChoice=="Cancel & Close"){
            if(isNaN(MinParticleDiameterSelectedChI)){
              exit(PluginName+ " Information:\nThe function "+ MacroName+" has stopped because the Min Particle Diameter for "+NameSelectedChI+" wasn't numeric");
            }else if (isNaN(MaxParticleDiameterSelectedChI)) {
              exit(PluginName+ " Information:\nThe function "+ MacroName+" has stopped because the Max Particle Diameter for "+NameSelectedChI+" wasn't numeric");
            } else {
              exit(PluginName+ " Information:\nThe function "+ MacroName+" has stopped because the Min Particle Diameter for "+NameSelectedChI+" was smaller than 0.");
            }
          } else if(UserChoice=="Try Again"){
            if(isNaN(MinParticleDiameterSelectedChI)|| MinParticleDiameterSelectedChI<0){
              MinParticleDiameterSelectedChI=0;
            } else if (isNaN(MaxParticleDiameterSelectedChI)){
              MaxParticleDiameterSelectedChI=100;
            }
          } // End of if user try Again
        } else{ // end of if particle is NaN
          DialogPass=1;
        } // End of else dialog pass
      } while(DialogPass!=1) // End of Do Dialog box
      if(UserChoiceDetection=="Move to Next"){
        ParticleDetectionPass=1;
      } // End of UserCHoice detection
    } while(ParticleDetectionPass!=1) // End of Do loop Analyze particle


    // Update the list of Ch Particle Diameter and Circularity
    ListChMinParticleDiameter[SelectedChIListPos]=MinParticleDiameterSelectedChI; // This is the particle diameter in Unit^2 for ChI
    ListChMaxParticleDiameter[SelectedChIListPos]=MaxParticleDiameterSelectedChI;
    ListChMinParticleCircularity[SelectedChIListPos]=MinParticleCircularitySelectedChI;
    ListChMaxParticleCircularity[SelectedChIListPos]=MaxParticleCircularitySelectedChI;
  } // End of If process is Individual

  // Now we have the Particle detected we can save it as an Overlay
  //setBatchMode("hide");
  ChNb=ChI+1;
  selectWindow(NameSelectedChI);
  OutputParticleImageChI=OutputImagePath+InputFileNameINoExt+"_Ch"+ChNb+"_"+NameSelectedChI+"_CellCount_Overlay.tif";
  saveAs("Tiff", OutputParticleImageChI);
  rename(NameSelectedChI);

  // Print the parameter into the text file
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Lower Threshold"+CellSeparator+LowerThresholdSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Upper Threshold"+CellSeparator+UpperThresholdSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Min Particle Diameter ("+RescaledUnit+")"+CellSeparator+MinParticleDiameterSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Max Particle Diameter ("+RescaledUnit+")"+CellSeparator+MaxParticleDiameterSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Min Particle Area ("+RescaledUnit+"^2)"+CellSeparator+MinParticleAreaSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Max Particle Area ("+RescaledUnit+"^2)"+CellSeparator+MaxParticleAreaSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Min Particle Circularity (0-100)"+CellSeparator+MinParticleCircularitySelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Max Particle Circularity (0-100)"+CellSeparator+MaxParticleCircularitySelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Remove Noise Option"+CellSeparator+RemoveNoiseStatusSelectedChI+LineSeparator);
  print("[ParameterData]", InputFileNameINoExt+CellSeparator+NameSelectedChI+CellSeparator+"Watershed Option"+CellSeparator+WatershedStatusSelectedChI+LineSeparator);


  // ReAnalyze particle on Selected ChI to have the DATA this time
  selectWindow(NameSelectedChI);
  run("Select None");
  run("Remove Overlay");
  if(FirstResult=="true"){
    run("Clear Results");
    setResult("Area",nResults,0);     // Add a blank results line and column just in case the analysis particle is gives an empty results
    NbOfParticles=0;
    FirstResult="false";
  }

  run("Set Measurements...", "area mean standard modal min centroid center perimeter bounding fit shape feret's integrated median skewness kurtosis area_fraction stack display invert redirect=None decimal=9");
  selectWindow(NameSelectedChI);

  run("Analyze Particles...", "size=&MinParticleAreaSelectedChI-&MaxParticleAreaSelectedChI circularity=&MinParticleCircularitySelectedChIDecimal-&MaxParticleCircularitySelectedChIDecimal show=Masks display summarize in_situ");
  selectWindow("Results");
  //Add the Label and Channel Names to the Results

  if(NbOfParticles<nResults){
    for(i=NbOfParticles;i<nResults;i++){
      setResult("Label", i, InputFileNameINoExt);
      setResult("Channel", i, NameSelectedChI);
    }
    NbOfParticles=nResults;
  }
  selectWindow("Results");
  updateResults();
  selectWindow("Summary");
  setLocation(ToolbarPosX+ToolbarSizeX, ToolbarPosY);

  // Create a selection add to the roi Manager
  selectWindow(NameSelectedChI); // This is the Mask after the particle detection
  run("Create Selection");
  // Make Sure the selection is not empty
  getSelectionBounds(SelectionPosX, SelectionPosY, SelectionWidth, SelectionHeight);
  getDimensions(ImageWidth, ImageHeight, NbChannels, NbSlices, NbFrames); // Get dimensions of the Image
  // If the selection is empty ImageJ will use X=0 Y=0 Width=Height=1 or Width=Height=MaxImageHeight
  if(SelectionPosX==0 && SelectionPosY==0 && ((SelectionWidth==1 && SelectionHeight==1) || (SelectionWidth==ImageWidth && SelectionHeight==ImageHeight) )){
    run("Select None");
    makeRectangle(0, 0, 1, 1);
  }
  roiManager("Add");
  NbROI=roiManager("count");
  roiManager("Select", NbROI-1);
  roiManager("Rename", NameSelectedChI);
  roiManager("Set Color", "magenta");
  roiManager("Set Line Width", 10);
  // Do not close each individual channels because we will use it for combination
}// end for ChI
////////////////////////////////////////////// End Duplicate and threshold the Staining channels
//setBatchMode("hide");
if(ProcessingMethod=="Global" && FileI>0){
  //  do nothing
} else { //update the Preferences
  for(i=0;i<ListChSelectionStatus.length;i++){
    if(i==0){
      ListChLowerThresholdString=""+ListChLowerThreshold[i];
      ListChUpperThresholdString=""+ListChUpperThreshold[i];
      ListChMinParticleDiameterString=""+ListChMinParticleDiameter[i];
      ListChMaxParticleDiameterString=""+ListChMaxParticleDiameter[i];
      ListChMinParticleCircularityString=""+ListChMinParticleCircularity[i];
      ListChMaxParticleCircularityString=""+ListChMaxParticleCircularity[i];
      ListChRemoveNoiseStatusString=""+ListChRemoveNoiseStatus[i];
      ListChWatershedStatusString=""+ListChWatershedStatus[i];
    }else{
      ListChLowerThresholdString=ListChLowerThresholdString+","+ListChLowerThreshold[i];
      ListChUpperThresholdString=ListChUpperThresholdString+","+ListChUpperThreshold[i];
      ListChMinParticleDiameterString=ListChMinParticleDiameterString+","+ListChMinParticleDiameter[i];
      ListChMaxParticleDiameterString=ListChMaxParticleDiameterString+","+ListChMaxParticleDiameter[i];
      ListChMinParticleCircularityString=ListChMinParticleCircularityString+","+ListChMinParticleCircularity[i];
      ListChMaxParticleCircularityString=ListChMaxParticleCircularityString+","+ListChMaxParticleCircularity[i];
      ListChRemoveNoiseStatusString=ListChRemoveNoiseStatusString+","+ListChRemoveNoiseStatus[i];
      ListChWatershedStatusString=ListChWatershedStatusString+","+ListChWatershedStatus[i];
    }
  } // end of for i

  // Save the parameters in the Preferences
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChLowerThreshold",ListChLowerThresholdString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChUpperThreshold",ListChUpperThresholdString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChMinParticleDiameter",ListChMinParticleDiameterString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChMaxParticleDiameter",ListChMaxParticleDiameterString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChMinParticleCircularity",ListChMinParticleCircularityString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChMaxParticleCircularity",ListChMaxParticleCircularityString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChRemoveNoiseStatus",ListChRemoveNoiseStatusString);
  call("ij.Prefs.set", "Default."+PluginName+"."+MacroName+".ListChWatershedStatus",ListChWatershedStatusString);
}// end of if not global then save the parameters







//setBatchMode("hide");
///////////////////////// Combine 2 channels
///////////////////////// Combine 2 channels
if(ListSelectedCh.length>1){
  for (ChIA=0; ChIA < ListSelectedCh.length-1; ChIA++){
    for (ChIB=ChIA+1; ChIB < ListSelectedCh.length; ChIB++){
      SelectedChIA=ListSelectedCh[ChIA]; //This is the number of the selected channels >=1 it can be above 5 if user select only channel 2 and 7 for example.
      SelectedChIAListPos=SelectedChIA-1; // This is the position within the array of the SelectedChIA
      NameSelectedChIA=ListChName[SelectedChIAListPos]; // This is the Name of the Selected Channels
      LowerThresholdSelectedChIA=ListChLowerThreshold[SelectedChIAListPos]; // This is the LowerThreshold for the Channel I
      UpperThresholdSelectedChIA=ListChUpperThreshold[SelectedChIAListPos];// This is the UpperThreshold for the Channel I
      RemoveNoiseStatusSelectedChIA=ListChRemoveNoiseStatus[SelectedChIAListPos]; // This is 1 or 0 if we apply or not Remove Noise function
      WatershedStatusSelectedChIA=ListChWatershedStatus[SelectedChIAListPos];// This is 1 or 0 if we apply or not Watershed function
      MinParticleDiameterSelectedChIA=ListChMinParticleDiameter[SelectedChIAListPos]; // This is the particle diameter in Unit^2 for ChIA
      MaxParticleDiameterSelectedChIA=ListChMaxParticleDiameter[SelectedChIAListPos]; // This is the  percentage of variation allowed around the particle diameterfor ChIA
      MinParticleCircularitySelectedChIA=ListChMinParticleCircularity[SelectedChIAListPos]; // This is the particle diameter in Unit^2 for ChIA
      MaxParticleCircularitySelectedChIA=ListChMaxParticleCircularity[SelectedChIAListPos]; // This is the particle diameter in Unit^2 for ChI

      SelectedChIB=ListSelectedCh[ChIB]; //This is the number of the selected channels >=1 it can be above 5 if user select only channel 2 and 7 for example.
      SelectedChIBListPos=SelectedChIB-1; // This is the position within the array of the SelectedChIB
      NameSelectedChIB=ListChName[SelectedChIBListPos]; // This is the Name of the Selected Channels
      LowerThresholdSelectedChIB=ListChLowerThreshold[SelectedChIBListPos]; // This is the LowerThreshold for the Channel I
      UpperThresholdSelectedChIB=ListChUpperThreshold[SelectedChIBListPos];// This is the UpperThreshold for the Channel I
      RemoveNoiseStatusSelectedChIB=ListChRemoveNoiseStatus[SelectedChIBListPos]; // This is 1 or 0 if we apply or not Remove Noise function
      WatershedStatusSelectedChIB=ListChWatershedStatus[SelectedChIBListPos];// This is 1 or 0 if we apply or not Watershed function
      MinParticleDiameterSelectedChIB=ListChMinParticleDiameter[SelectedChIBListPos]; // This is the particle diameter in Unit^2 for ChIB
      MaxParticleDiameterSelectedChIB=ListChMaxParticleDiameter[SelectedChIBListPos]; // This is the  percentage of variation allowed around the particle diameterfor ChIB
      MinParticleCircularitySelectedChIB=ListChMinParticleCircularity[SelectedChIBListPos]; // This is the particle diameter in Unit^2 for ChIB
      MaxParticleCircularitySelectedChIB=ListChMaxParticleCircularity[SelectedChIBListPos]; // This is the particle diameter in Unit^2 for ChI

      CombinedParticleDiameterArray=newArray(MinParticleDiameterSelectedChIA, MaxParticleDiameterSelectedChIA,MinParticleDiameterSelectedChIB, MaxParticleDiameterSelectedChIB);
      CombinedParticleCircularityArray=newArray(MinParticleCircularitySelectedChIA, MaxParticleCircularitySelectedChIA,MinParticleCircularitySelectedChIB, MaxParticleCircularitySelectedChIB);
      CombinedChNameI=""+NameSelectedChIA+"x"+NameSelectedChIB;
      CombinedChNbI="_Ch"+ChIA+1+"xCh"+ChIB+1+"_";
      OutputResultsPathCombinedChI=OutputTablePath+InputFileNameINoExt+CombinedChNbI+CombinedChNameI+"_CellCount_DetailedResult.txt";
      OutputParticleImageCombinedChI=OutputImagePath+InputFileNameINoExt+CombinedChNbI+CombinedChNameI+"_CellCount_Overlay.tif";

      Array.getStatistics(CombinedParticleDiameterArray, MinParticleDiameterCombinedChI, MaxParticleDiameterCombinedChI, MeanParticleDiameterCombinedChI, StDevParticleDiameterCombinedChI);
      MinParticleAreaCombinedChI=PI*MinParticleDiameterCombinedChI*MinParticleDiameterCombinedChI;
      MaxParticleAreaCombinedChI=PI*MaxParticleDiameterCombinedChI*MaxParticleDiameterCombinedChI;

      Array.getStatistics(CombinedParticleCircularityArray, MinParticleCircularityCombinedChI, MaxParticleCircularityCombinedChI, MeanParticleCircularityCombinedChI, StDevParticleCircularityCombinedChI);
      MinParticleCircularityCombinedChIDecimal=MinParticleCircularityCombinedChI/100;
      MaxParticleCircularityCombinedChIDecimal=MaxParticleCircularityCombinedChI/100;

      selectWindow(NameSelectedChIA);
      run("Select None");
      run("Duplicate...", "title=CombinedChImage duplicate");
      selectWindow("CombinedChImage");
      imageCalculator("AND","CombinedChImage", NameSelectedChIB);
      selectWindow("CombinedChImage");
      rename(CombinedChNameI);

      selectWindow(CombinedChNameI);
      run("Select None");// Remove any selection
      run("Remove Overlay");
      selectWindow(CombinedChNameI);
      run("Duplicate...", "title=CombinedChImageForROI duplicate");
      selectWindow("CombinedChImageForROI");
      run("Analyze Particles...", "size=&MinParticleAreaCombinedChI-&MaxParticleAreaCombinedChI circularity=&MinParticleCircularityCombinedChIDecimal-&MaxParticleCircularityCombinedChIDecimal show=Masks in_situ");
      selectWindow("CombinedChImageForROI");
      run("Create Selection");

      getSelectionBounds(SelectionPosX, SelectionPosY, SelectionWidth, SelectionHeight);
      getDimensions(ImageWidth, ImageHeight, NbChannels, NbSlices, NbFrames); // Get dimensions of the Image
      // If the selection is empty ImageJ will use X=0 Y=0 Width=Height=1 or Width=Height=MaxImageHeight
      if(SelectionPosX==0 && SelectionPosY==0 && ((SelectionWidth==1 && SelectionHeight==1) || (SelectionWidth==ImageWidth && SelectionHeight==ImageHeight) )){
        run("Select None");
        makeRectangle(0, 0, 1, 1);
      }
      roiManager("Add");
      NbROI=roiManager("count");
      roiManager("Select", NbROI-1);
      roiManager("Rename", CombinedChNameI);
      roiManager("Set Color", "magenta");
      roiManager("Set Line Width", 10);
      selectWindow("CombinedChImageForROI");
      close();

      // Run again the analyze Particle for the Detailed results and the overlay
      run("Set Measurements...", "area mean standard modal min centroid center perimeter bounding fit shape feret's integrated median skewness kurtosis area_fraction stack display invert redirect=None decimal=9");
      selectWindow(CombinedChNameI);
      run("Analyze Particles...", "size=&MinParticleAreaCombinedChI-&MaxParticleAreaCombinedChI circularity=&MinParticleCircularityCombinedChIDecimal-&MaxParticleCircularityCombinedChIDecimal show=[Overlay Masks] display summarize in_situ");
      selectWindow("Results");
      //Add the Label and Channel Names to the Results
      if(NbOfParticles<nResults){
        for(i=NbOfParticles;i<nResults;i++){
          setResult("Label", i, InputFileNameINoExt);
          setResult("Channel", i, CombinedChNameI);
        }
        NbOfParticles=nResults;
      }

      selectWindow("Results");
      updateResults();
      selectWindow(CombinedChNameI);
      run("Overlay Options...", "stroke=magenta width=1 fill=cyan apply show");
      run("Labels...", "color=blue font=10 show bold");


      selectWindow(CombinedChNameI);
      saveAs("Tiff", OutputParticleImageCombinedChI);
      close();

      print("[ParameterData]", InputFileNameINoExt+CellSeparator+CombinedChNameI+CellSeparator+"Min Particle Diameter ("+RescaledUnit+")"+CellSeparator+MinParticleDiameterCombinedChI+LineSeparator);
      print("[ParameterData]", InputFileNameINoExt+CellSeparator+CombinedChNameI+CellSeparator+"Max Particle Diameter ("+RescaledUnit+")"+CellSeparator+MaxParticleDiameterCombinedChI+LineSeparator);
      print("[ParameterData]", InputFileNameINoExt+CellSeparator+CombinedChNameI+CellSeparator+"Min Particle Area ("+RescaledUnit+"^2)"+CellSeparator+MinParticleAreaCombinedChI+LineSeparator);
      print("[ParameterData]", InputFileNameINoExt+CellSeparator+CombinedChNameI+CellSeparator+"Max Particle Area ("+RescaledUnit+"^2)"+CellSeparator+MaxParticleAreaCombinedChI+LineSeparator);
      print("[ParameterData]", InputFileNameINoExt+CellSeparator+CombinedChNameI+CellSeparator+"Min Particle Circularity (0-100)"+CellSeparator+MinParticleCircularityCombinedChI+LineSeparator);
      print("[ParameterData]", InputFileNameINoExt+CellSeparator+CombinedChNameI+CellSeparator+"Max Particle Circularity (0-100)"+CellSeparator+MaxParticleCircularityCombinedChI+LineSeparator);
    }// end for ChIB
  }// for ChIA
} // End of if more than 1 selected channel

///////////////////////// Close the individual Channels
///////////////////////// Close the individual Channels
///////////////////////// Close the individual Channels
///////////////////////// Close the individual Channels
///////////////////////// Close the individual Channels
///////////////////////// Close the individual Channels
for(ChI=0; ChI<ListSelectedCh.length; ChI++){
  SelectedChI=ListSelectedCh[ChI];
  SelectedChIListPos=SelectedChI-1;
  NameSelectedChI=ListChName[SelectedChIListPos];
  selectWindow(NameSelectedChI);
  close();
}///////////////////////// End of Close the Channels


////////// Get the Values of the whole Staining for each Channel and add it to the Measurements Textwindow
for (ChI=0; ChI<ListSelectedCh.length; ChI++){
  SelectedChI=ListSelectedCh[ChI];
  SelectedChIListPos=SelectedChI-1;
  NameSelectedChI=ListChName[SelectedChIListPos];

  if(ChI==0){
    run("Text Window...", "name=MeasurementData width=50 height=6 menu");
    setLocation(ToolbarPosX+ToolbarSizeX+Spacer, ToolbarPosY);
    List.setMeasurements; // For the first time add the header to MeasurementData
    MeasurementsHeader=List.getList;
    MeasurementsHeader=replace(MeasurementsHeader,"=.*\n",",");
    print("[MeasurementData]", "Filename"+CellSeparator+"Measurement Category"+CellSeparator+"Channel"+CellSeparator+"ROI"+CellSeparator+MeasurementsHeader+LineSeparator);
  }

  NbROI=roiManager("count");
  selectWindow("Original");
  if(ListSelectedCh.length>1){
    Stack.setChannel(SelectedChI);
  }
  for (ROIn=0; ROIn<NbROI; ROIn++){
    roiManager("Select", ROIn);
    ROINameI=call("ij.plugin.frame.RoiManager.getName", ROIn);
    List.setMeasurements;
    MeasurementsChI=List.getList;
    MeasurementsChI=replace(MeasurementsChI,"%Area=",""); // Remove the measurements Area
    MeasurementsChI=replace(MeasurementsChI,"\n.*=",",");
    MeasurementsChI=replace(MeasurementsChI,"\n","");
    print("[MeasurementData]", InputFileNameINoExt+CellSeparator+"Staining Measurements"+CellSeparator+NameSelectedChI+CellSeparator+ROINameI+CellSeparator+MeasurementsChI+LineSeparator);
  }//for each ChannelROI
}// end for ChI
///////////////////////// Get the Values of the whole Staining for each Channel and add it to the Measurements Textwindow


///////////////////////// Save the ROI
selectWindow(InputFileNameI);
roiManager("Deselect");
run("Select None");
OutputPathROI=OutputImagePath+InputFileNameINoExt+"_ROI.zip";
roiManager("Save", OutputPathROI);
roiManager("reset");
///////////////////////// Save the ROI

///////////////////////// Close the original files
selectWindow(InputFileNameI);
close();
selectWindow("Original");
close();
///////////////////////// Close the original file


OutputSummaryCountDataPath=OutputDirPath+InputFileNameINoExt+"_SummaryResults.txt";
selectWindow("Summary");
saveAs("Text", OutputSummaryCountDataPath);
selectWindow(InputFileNameINoExt+"_SummaryResults.txt");                     run("Close");


OutputMeasurementDataPath=OutputMeasurementPath+InputFileNameINoExt+"_Measurements.txt";
selectWindow("MeasurementData");
saveAs("Text", OutputMeasurementDataPath);
selectWindow(InputFileNameINoExt+"_Measurements.txt");                     run("Close");

///////////////////////// Save the text files with the data
OutputParameterDataPath=OutputParameterPath+InputFileNameINoExt+"_Parameters.txt";
selectWindow("ParameterData");
saveAs("Text", OutputParameterDataPath);                     run("Close");




OutputDetailedResultsPath=OutputTablePath+InputFileNameINoExt+"_CellCount_DetailedResult.txt";
selectWindow("Results");
saveAs("Text", OutputDetailedResultsPath);                    run("Clear Results");                    run("Close");


///////////////////////// Update the progress bar
showProgress(FileI, InputFileList.length);



} ///////////////////////// End for FileI loop
UtilityWindowsToCloseArray=newArray("Threshold", "Results", "ROI Manager", "B&C");
CloseAndCleanUp(UtilityWindowsToCloseArray);
